{
  "master": {
    "tasks": [
      {
        "id": 25,
        "title": "Configurar Arquitectura Multi-Tenant Base",
        "description": "Establecer la estructura base para soportar m煤ltiples tenants (realtors) con aislamiento de datos y configuraci贸n.",
        "details": "Implementar un sistema de identificaci贸n de tenants basado en subdominios y dominios personalizados. Crear un esquema de base de datos que soporte el aislamiento de datos por tenant. Configurar middleware para la resoluci贸n de tenants basado en la URL.\n\n```python\n# Ejemplo de middleware para resoluci贸n de tenant en FastAPI\nfrom fastapi import Request, Depends\n\nasync def tenant_middleware(request: Request):\n    host = request.headers.get('host', '')\n    # Extraer tenant_id del subdominio o buscar en la tabla de dominios personalizados\n    tenant_id = extract_tenant_from_host(host)\n    request.state.tenant_id = tenant_id\n    return tenant_id\n\n# Esquema de base de datos para tenants\n'''\nCREATE TABLE tenants (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    subdomain VARCHAR(255) UNIQUE NOT NULL,\n    custom_domain VARCHAR(255) UNIQUE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n'''\n```",
        "testStrategy": "Crear tests unitarios para la resoluci贸n de tenants basada en subdominios y dominios personalizados. Verificar el correcto aislamiento de datos entre tenants. Probar la creaci贸n, actualizaci贸n y eliminaci贸n de tenants.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Tenant Identification Strategy",
            "description": "Define and implement a method to identify tenants using subdomains and custom domains, ensuring each request is correctly mapped to its tenant.",
            "dependencies": [],
            "details": "Establish rules for extracting tenant identifiers from incoming URLs, considering both subdomain and custom domain scenarios. Document the mapping logic and edge cases.",
            "status": "done",
            "testStrategy": "Create unit tests to verify tenant extraction from various URL formats, including edge cases and invalid domains."
          },
          {
            "id": 2,
            "title": "Implement Tenant Resolution Middleware",
            "description": "Develop middleware to resolve and attach the tenant context to each request based on the identification strategy.",
            "dependencies": [
              "25.1"
            ],
            "details": "Integrate middleware into the application stack (e.g., FastAPI) that uses the identification logic to set the tenant context for downstream processing.",
            "status": "done",
            "testStrategy": "Test middleware with simulated requests to ensure correct tenant context is set for all supported domain patterns."
          },
          {
            "id": 3,
            "title": "Design Multi-Tenant Database Schema",
            "description": "Create a database schema that supports data isolation per tenant, using schemas or tenant-specific tables as appropriate.",
            "dependencies": [
              "25.1"
            ],
            "details": "Evaluate and select a multi-tenant database pattern (e.g., shared schema with tenant_id column, separate schemas per tenant) based on isolation and scalability requirements. Implement the chosen schema in the database.",
            "status": "done",
            "testStrategy": "Verify that data for one tenant is inaccessible to others through direct queries and application logic. Test schema creation and migration processes."
          },
          {
            "id": 4,
            "title": "Implement Tenant Management Operations",
            "description": "Develop functionality to create, update, and delete tenants, ensuring proper setup and teardown of associated resources.",
            "dependencies": [
              "25.3"
            ],
            "details": "Automate the provisioning of database schemas or tables and domain mappings when a new tenant is created. Ensure cleanup on tenant deletion.",
            "status": "pending",
            "testStrategy": "Test tenant lifecycle operations, verifying that resources are correctly created and removed, and that no data leakage occurs between tenants."
          },
          {
            "id": 5,
            "title": "Validate Data Isolation and Tenant Resolution",
            "description": "Conduct comprehensive testing to ensure strict data isolation and correct tenant resolution across all layers.",
            "dependencies": [
              "25.2",
              "25.3",
              "25.4"
            ],
            "details": "Perform integration and security tests to confirm that requests are always processed in the correct tenant context and that no cross-tenant data access is possible.",
            "status": "pending",
            "testStrategy": "Simulate concurrent requests from multiple tenants, attempt unauthorized data access, and verify that isolation and resolution mechanisms are robust."
          }
        ]
      },
      {
        "id": 26,
        "title": "Implementar Sistema de Autenticaci贸n con Supabase",
        "description": "Configurar Supabase para la autenticaci贸n y gesti贸n de usuarios, tanto para realtors (tenants) como para usuarios finales.",
        "details": "Integrar Supabase Auth para manejar el registro, inicio de sesi贸n y gesti贸n de usuarios. Crear dos niveles de usuarios: realtors (administradores) y usuarios finales (clientes). Implementar JWT para la autenticaci贸n en la API.\n\n```javascript\n// Ejemplo de configuraci贸n de Supabase en Nuxt.js\n// nuxt.config.js\nexport default {\n  modules: ['@nuxtjs/supabase'],\n  supabase: {\n    url: process.env.SUPABASE_URL,\n    key: process.env.SUPABASE_KEY,\n    redirect: {\n      login: '/login',\n      callback: '/confirm',\n      exclude: ['/'],\n    },\n  }\n}\n\n// Ejemplo de uso en componente Vue\nconst { auth } = useSupabaseClient()\nconst user = useSupabaseUser()\n\nconst login = async () => {\n  const { error } = await auth.signInWithPassword({\n    email: email.value,\n    password: password.value,\n  })\n}\n```",
        "testStrategy": "Probar flujos de registro, inicio de sesi贸n, recuperaci贸n de contrase帽a y cierre de sesi贸n. Verificar la correcta asignaci贸n de roles y permisos. Probar la integraci贸n con la API principal mediante tokens JWT.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Dise帽ar e Implementar Esquema de Base de Datos PostgreSQL",
        "description": "Crear el esquema de base de datos relacional en PostgreSQL para almacenar propiedades, usuarios, transacciones y configuraciones de tenants.",
        "details": "Dise帽ar tablas para propiedades, usuarios, transacciones, configuraciones de tenant, y relaciones entre ellas. Implementar esquemas separados por tenant para garantizar el aislamiento de datos. Configurar 铆ndices para optimizar consultas frecuentes.\n\n```sql\n-- Esquema base para cada tenant\nCREATE SCHEMA tenant_{tenant_id};\n\n-- Tabla de propiedades\nCREATE TABLE tenant_{tenant_id}.properties (\n    id SERIAL PRIMARY KEY,\n    title VARCHAR(255) NOT NULL,\n    description TEXT,\n    property_type VARCHAR(50) NOT NULL,\n    price DECIMAL(12,2) NOT NULL,\n    address VARCHAR(255) NOT NULL,\n    city VARCHAR(100) NOT NULL,\n    state VARCHAR(100),\n    zip_code VARCHAR(20),\n    latitude DECIMAL(10,8),\n    longitude DECIMAL(11,8),\n    bedrooms INT,\n    bathrooms DECIMAL(3,1),\n    area DECIMAL(10,2),\n    status VARCHAR(50) NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Tabla de clientes (leads)\nCREATE TABLE tenant_{tenant_id}.leads (\n    id SERIAL PRIMARY KEY,\n    user_id UUID REFERENCES auth.users(id),\n    first_name VARCHAR(100),\n    last_name VARCHAR(100),\n    email VARCHAR(255),\n    phone VARCHAR(50),\n    status VARCHAR(50),\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Tabla de transacciones\nCREATE TABLE tenant_{tenant_id}.transactions (\n    id SERIAL PRIMARY KEY,\n    lead_id INT REFERENCES tenant_{tenant_id}.leads(id),\n    property_id INT REFERENCES tenant_{tenant_id}.properties(id),\n    transaction_type VARCHAR(50) NOT NULL,\n    stage VARCHAR(50) NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n```",
        "testStrategy": "Verificar la integridad referencial entre tablas. Probar consultas complejas para asegurar rendimiento. Validar el aislamiento de datos entre tenants. Realizar pruebas de carga para evaluar el rendimiento con grandes vol煤menes de datos.",
        "priority": "high",
        "dependencies": [
          25
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Desarrollar API RESTful con FastAPI",
        "description": "Implementar la API principal utilizando FastAPI para manejar todas las operaciones CRUD y l贸gica de negocio.",
        "details": "Crear endpoints RESTful para gestionar propiedades, usuarios, transacciones y configuraciones de tenant. Implementar validaci贸n de datos con Pydantic. Configurar autenticaci贸n JWT y autorizaci贸n basada en roles. Documentar la API con Swagger/OpenAPI.\n\n```python\nfrom fastapi import FastAPI, Depends, HTTPException, status\nfrom typing import List, Optional\nfrom pydantic import BaseModel\nfrom datetime import datetime\n\napp = FastAPI(title=\"Plataforma Inmobiliaria API\")\n\nclass PropertyBase(BaseModel):\n    title: str\n    description: Optional[str] = None\n    property_type: str\n    price: float\n    address: str\n    city: str\n    state: Optional[str] = None\n    zip_code: Optional[str] = None\n    latitude: Optional[float] = None\n    longitude: Optional[float] = None\n    bedrooms: Optional[int] = None\n    bathrooms: Optional[float] = None\n    area: Optional[float] = None\n    status: str\n\nclass PropertyCreate(PropertyBase):\n    pass\n\nclass Property(PropertyBase):\n    id: int\n    created_at: datetime\n    updated_at: datetime\n\n    class Config:\n        orm_mode = True\n\n@app.post(\"/properties/\", response_model=Property)\nasync def create_property(\n    property: PropertyCreate, \n    tenant_id: str = Depends(tenant_middleware),\n    current_user: User = Depends(get_current_user)\n):\n    # Verificar permisos del usuario\n    if not current_user.is_realtor:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n    \n    # Crear propiedad en la base de datos del tenant\n    db_property = await database.create_property(tenant_id, property)\n    return db_property\n```",
        "testStrategy": "Crear tests unitarios para cada endpoint. Implementar tests de integraci贸n para flujos completos. Verificar la correcta validaci贸n de datos y manejo de errores. Probar la autenticaci贸n y autorizaci贸n para diferentes roles de usuario.",
        "priority": "high",
        "dependencies": [
          26,
          27
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Implementar Frontend Base con Nuxt.js",
        "description": "Configurar el proyecto Nuxt.js con TailwindCSS y Pinia para el frontend, estableciendo la estructura base para portales de cliente y dashboard de realtor.",
        "details": "Configurar Nuxt.js 3 con Vue 3, TailwindCSS para estilos y Pinia para gesti贸n de estado. Implementar enrutamiento din谩mico basado en tenant. Crear layouts separados para portal de cliente y dashboard de realtor.\n\n```bash\n# Instalaci贸n de dependencias\nnpm init nuxt-app plataforma-inmobiliaria\ncd plataforma-inmobiliaria\nnpm install @nuxtjs/tailwindcss pinia @pinia/nuxt @nuxtjs/supabase\n```\n\n```javascript\n// nuxt.config.js\nexport default defineNuxtConfig({\n  modules: [\n    '@nuxtjs/tailwindcss',\n    '@pinia/nuxt',\n    '@nuxtjs/supabase'\n  ],\n  app: {\n    head: {\n      title: 'Plataforma Inmobiliaria',\n      meta: [\n        { charset: 'utf-8' },\n        { name: 'viewport', content: 'width=device-width, initial-scale=1' }\n      ]\n    }\n  },\n  runtimeConfig: {\n    public: {\n      apiBaseUrl: process.env.API_BASE_URL || 'http://localhost:8000'\n    }\n  }\n})\n```\n\n```javascript\n// store/tenant.js\nimport { defineStore } from 'pinia'\n\nexport const useTenantStore = defineStore('tenant', {\n  state: () => ({\n    currentTenant: null,\n    branding: {\n      logo: null,\n      primaryColor: '#3B82F6',\n      secondaryColor: '#1E3A8A'\n    }\n  }),\n  actions: {\n    async fetchTenantInfo(tenantId) {\n      // Obtener informaci贸n del tenant desde la API\n      const { data } = await useFetch(`/api/tenants/${tenantId}`)\n      this.currentTenant = data.value\n      this.branding = data.value.branding\n    }\n  }\n})\n```",
        "testStrategy": "Realizar pruebas de componentes con Vue Test Utils. Verificar la correcta renderizaci贸n de layouts seg煤n el tenant. Probar la integraci贸n con Pinia para la gesti贸n de estado. Validar la responsividad en diferentes dispositivos.",
        "priority": "high",
        "dependencies": [
          25,
          26
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Desarrollar Sistema de Personalizaci贸n de Branding por Tenant",
        "description": "Implementar la funcionalidad que permite a cada realtor personalizar su portal con logo, colores y estilos propios.",
        "details": "Crear un sistema de temas din谩micos basado en la configuraci贸n del tenant. Implementar un panel de configuraci贸n en el dashboard del realtor para subir logo y seleccionar colores. Almacenar la configuraci贸n en la base de datos y aplicarla din谩micamente en el frontend.\n\n```javascript\n// components/TenantBrandingConfig.vue\n<template>\n  <div class=\"branding-config\">\n    <h2>Personalizaci贸n de Marca</h2>\n    <div class=\"form-group\">\n      <label>Logo</label>\n      <input type=\"file\" @change=\"uploadLogo\" accept=\"image/*\" />\n      <img v-if=\"branding.logo\" :src=\"branding.logo\" class=\"preview\" />\n    </div>\n    <div class=\"form-group\">\n      <label>Color Primario</label>\n      <input type=\"color\" v-model=\"branding.primaryColor\" />\n    </div>\n    <div class=\"form-group\">\n      <label>Color Secundario</label>\n      <input type=\"color\" v-model=\"branding.secondaryColor\" />\n    </div>\n    <button @click=\"saveBranding\" class=\"btn-save\">Guardar Cambios</button>\n  </div>\n</template>\n\n<script setup>\nimport { ref, onMounted } from 'vue'\nimport { useTenantStore } from '~/store/tenant'\n\nconst tenantStore = useTenantStore()\nconst branding = ref({\n  logo: null,\n  primaryColor: '#3B82F6',\n  secondaryColor: '#1E3A8A'\n})\n\nonMounted(async () => {\n  // Cargar configuraci贸n actual\n  branding.value = { ...tenantStore.branding }\n})\n\nasync function uploadLogo(event) {\n  const file = event.target.files[0]\n  if (!file) return\n  \n  // Subir imagen a almacenamiento\n  const formData = new FormData()\n  formData.append('logo', file)\n  const { data } = await useFetch('/api/tenants/branding/logo', {\n    method: 'POST',\n    body: formData\n  })\n  \n  branding.value.logo = data.value.url\n}\n\nasync function saveBranding() {\n  await useFetch('/api/tenants/branding', {\n    method: 'PUT',\n    body: branding.value\n  })\n  \n  // Actualizar store\n  tenantStore.branding = { ...branding.value }\n}\n</script>\n```\n\n```css\n/* CSS din谩mico basado en configuraci贸n del tenant */\n:root {\n  --primary-color: v-bind('tenantStore.branding.primaryColor');\n  --secondary-color: v-bind('tenantStore.branding.secondaryColor');\n}\n```",
        "testStrategy": "Probar la carga y almacenamiento de logos. Verificar la aplicaci贸n correcta de colores personalizados. Validar que los cambios se reflejen inmediatamente en el portal del cliente. Probar con diferentes combinaciones de colores y formatos de imagen.",
        "priority": "medium",
        "dependencies": [
          25,
          29
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "Implementar Gesti贸n de Propiedades en Dashboard de Realtor",
        "description": "Desarrollar la interfaz y funcionalidad CRUD para que los realtors puedan gestionar sus propiedades desde el dashboard.",
        "details": "Crear formularios para a帽adir, editar y eliminar propiedades. Implementar carga de im谩genes m煤ltiples. Desarrollar vista de listado con filtros y b煤squeda. Integrar con la API para operaciones CRUD.\n\n```javascript\n// pages/dashboard/properties/index.vue\n<template>\n  <div class=\"properties-dashboard\">\n    <h1>Gesti贸n de Propiedades</h1>\n    <div class=\"actions\">\n      <button @click=\"navigateTo('/dashboard/properties/new')\" class=\"btn-primary\">\n        A帽adir Propiedad\n      </button>\n    </div>\n    \n    <div class=\"filters\">\n      <input v-model=\"filters.search\" placeholder=\"Buscar...\" />\n      <select v-model=\"filters.status\">\n        <option value=\"\">Todos los estados</option>\n        <option value=\"active\">Activa</option>\n        <option value=\"pending\">Pendiente</option>\n        <option value=\"sold\">Vendida</option>\n        <option value=\"rented\">Alquilada</option>\n      </select>\n      <select v-model=\"filters.type\">\n        <option value=\"\">Todos los tipos</option>\n        <option value=\"house\">Casa</option>\n        <option value=\"apartment\">Apartamento</option>\n        <option value=\"land\">Terreno</option>\n      </select>\n    </div>\n    \n    <table class=\"properties-table\">\n      <thead>\n        <tr>\n          <th>ID</th>\n          <th>T铆tulo</th>\n          <th>Tipo</th>\n          <th>Precio</th>\n          <th>Estado</th>\n          <th>Acciones</th>\n        </tr>\n      </thead>\n      <tbody>\n        <tr v-for=\"property in filteredProperties\" :key=\"property.id\">\n          <td>{{ property.id }}</td>\n          <td>{{ property.title }}</td>\n          <td>{{ property.property_type }}</td>\n          <td>{{ formatCurrency(property.price) }}</td>\n          <td>{{ property.status }}</td>\n          <td class=\"actions\">\n            <button @click=\"editProperty(property.id)\" class=\"btn-edit\">Editar</button>\n            <button @click=\"confirmDelete(property.id)\" class=\"btn-delete\">Eliminar</button>\n          </td>\n        </tr>\n      </tbody>\n    </table>\n  </div>\n</template>\n\n<script setup>\nimport { ref, computed, onMounted } from 'vue'\n\nconst properties = ref([])\nconst filters = ref({\n  search: '',\n  status: '',\n  type: ''\n})\n\nonMounted(async () => {\n  await fetchProperties()\n})\n\nasync function fetchProperties() {\n  const { data } = await useFetch('/api/properties')\n  properties.value = data.value || []\n}\n\nconst filteredProperties = computed(() => {\n  return properties.value.filter(property => {\n    const matchesSearch = !filters.value.search || \n      property.title.toLowerCase().includes(filters.value.search.toLowerCase()) ||\n      property.address.toLowerCase().includes(filters.value.search.toLowerCase())\n    \n    const matchesStatus = !filters.value.status || property.status === filters.value.status\n    const matchesType = !filters.value.type || property.property_type === filters.value.type\n    \n    return matchesSearch && matchesStatus && matchesType\n  })\n})\n\nfunction editProperty(id) {\n  navigateTo(`/dashboard/properties/${id}/edit`)\n}\n\nasync function confirmDelete(id) {\n  if (confirm('驴Est谩 seguro de que desea eliminar esta propiedad?')) {\n    await useFetch(`/api/properties/${id}`, { method: 'DELETE' })\n    await fetchProperties()\n  }\n}\n\nfunction formatCurrency(value) {\n  return new Intl.NumberFormat('es-ES', {\n    style: 'currency',\n    currency: 'EUR'\n  }).format(value)\n}\n</script>\n```",
        "testStrategy": "Probar todas las operaciones CRUD de propiedades. Verificar la validaci贸n de formularios y manejo de errores. Comprobar la funcionalidad de filtrado y b煤squeda. Probar la carga y visualizaci贸n de im谩genes m煤ltiples. Verificar que los cambios se reflejen correctamente en el portal del cliente.",
        "priority": "high",
        "dependencies": [
          28,
          29
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Desarrollar Visualizaci贸n de Propiedades en Mapa Interactivo",
        "description": "Implementar un mapa interactivo como vista principal del portal del cliente, mostrando las propiedades disponibles con filtros y b煤squeda.",
        "details": "Integrar una biblioteca de mapas (como Mapbox o Leaflet) para mostrar propiedades georreferenciadas. Implementar clustering para mejorar el rendimiento con muchas propiedades. A帽adir filtros interactivos y b煤squeda. Mostrar informaci贸n b谩sica de la propiedad al hacer clic en un marcador.\n\n```javascript\n// components/PropertyMap.vue\n<template>\n  <div class=\"map-container\">\n    <div class=\"filters-panel\">\n      <input v-model=\"filters.search\" placeholder=\"Buscar por ubicaci贸n...\" />\n      <div class=\"price-range\">\n        <label>Precio:</label>\n        <input type=\"number\" v-model=\"filters.minPrice\" placeholder=\"M铆nimo\" />\n        <input type=\"number\" v-model=\"filters.maxPrice\" placeholder=\"M谩ximo\" />\n      </div>\n      <div class=\"property-type\">\n        <label>Tipo:</label>\n        <div v-for=\"type in propertyTypes\" :key=\"type.value\">\n          <input type=\"checkbox\" :value=\"type.value\" v-model=\"filters.types\" />\n          <span>{{ type.label }}</span>\n        </div>\n      </div>\n      <button @click=\"applyFilters\" class=\"btn-apply\">Aplicar Filtros</button>\n    </div>\n    \n    <div id=\"map\" ref=\"mapContainer\" class=\"map\"></div>\n    \n    <div v-if=\"selectedProperty\" class=\"property-preview\">\n      <img :src=\"selectedProperty.mainImage\" alt=\"Property\" />\n      <h3>{{ selectedProperty.title }}</h3>\n      <p class=\"price\">{{ formatCurrency(selectedProperty.price) }}</p>\n      <p class=\"address\">{{ selectedProperty.address }}</p>\n      <div class=\"features\">\n        <span>{{ selectedProperty.bedrooms }} hab</span>\n        <span>{{ selectedProperty.bathrooms }} ba帽os</span>\n        <span>{{ selectedProperty.area }} m虏</span>\n      </div>\n      <button @click=\"viewPropertyDetails(selectedProperty.id)\" class=\"btn-view\">\n        Ver Detalles\n      </button>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport { ref, onMounted, watch } from 'vue'\nimport mapboxgl from 'mapbox-gl'\nimport 'mapbox-gl/dist/mapbox-gl.css'\n\nconst mapContainer = ref(null)\nconst map = ref(null)\nconst properties = ref([])\nconst selectedProperty = ref(null)\nconst filters = ref({\n  search: '',\n  minPrice: null,\n  maxPrice: null,\n  types: []\n})\n\nconst propertyTypes = [\n  { value: 'house', label: 'Casa' },\n  { value: 'apartment', label: 'Apartamento' },\n  { value: 'land', label: 'Terreno' }\n]\n\nonMounted(async () => {\n  mapboxgl.accessToken = 'YOUR_MAPBOX_TOKEN'\n  \n  map.value = new mapboxgl.Map({\n    container: mapContainer.value,\n    style: 'mapbox://styles/mapbox/streets-v11',\n    center: [-3.7038, 40.4168], // Madrid como centro inicial\n    zoom: 12\n  })\n  \n  map.value.on('load', async () => {\n    await fetchProperties()\n    addPropertiesToMap()\n  })\n})\n\nasync function fetchProperties() {\n  const queryParams = new URLSearchParams()\n  if (filters.value.search) queryParams.append('search', filters.value.search)\n  if (filters.value.minPrice) queryParams.append('min_price', filters.value.minPrice)\n  if (filters.value.maxPrice) queryParams.append('max_price', filters.value.maxPrice)\n  if (filters.value.types.length) queryParams.append('types', filters.value.types.join(','))\n  \n  const { data } = await useFetch(`/api/properties?${queryParams.toString()}`)\n  properties.value = data.value || []\n}\n\nfunction addPropertiesToMap() {\n  // Limpiar marcadores existentes\n  const markers = document.querySelectorAll('.mapboxgl-marker')\n  markers.forEach(marker => marker.remove())\n  \n  // A帽adir nuevos marcadores\n  properties.value.forEach(property => {\n    if (!property.latitude || !property.longitude) return\n    \n    const marker = new mapboxgl.Marker()\n      .setLngLat([property.longitude, property.latitude])\n      .addTo(map.value)\n    \n    marker.getElement().addEventListener('click', () => {\n      selectedProperty.value = property\n    })\n  })\n}\n\nfunction applyFilters() {\n  fetchProperties().then(() => addPropertiesToMap())\n}\n\nfunction viewPropertyDetails(id) {\n  navigateTo(`/properties/${id}`)\n}\n\nfunction formatCurrency(value) {\n  return new Intl.NumberFormat('es-ES', {\n    style: 'currency',\n    currency: 'EUR'\n  }).format(value)\n}\n\nwatch(selectedProperty, () => {\n  if (selectedProperty.value) {\n    map.value.flyTo({\n      center: [selectedProperty.value.longitude, selectedProperty.value.latitude],\n      zoom: 15\n    })\n  }\n})\n</script>\n```",
        "testStrategy": "Verificar la correcta carga y visualizaci贸n de propiedades en el mapa. Probar la funcionalidad de filtrado y b煤squeda. Comprobar el rendimiento con un gran n煤mero de propiedades. Validar la interacci贸n con los marcadores y la visualizaci贸n de detalles de propiedad. Probar en diferentes dispositivos y tama帽os de pantalla.",
        "priority": "high",
        "dependencies": [
          28,
          29
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 33,
        "title": "Implementar Sistema de Gesti贸n de Leads y CRM",
        "description": "Desarrollar la funcionalidad de CRM para que los realtors puedan gestionar sus leads (clientes potenciales) y hacer seguimiento de su actividad.",
        "details": "Crear un sistema de gesti贸n de leads con informaci贸n de contacto y preferencias. Implementar seguimiento de actividad del cliente en el portal (propiedades vistas, favoritas, visitas agendadas). Desarrollar dashboard con m茅tricas y visualizaciones para el realtor.\n\n```javascript\n// pages/dashboard/leads/index.vue\n<template>\n  <div class=\"leads-dashboard\">\n    <h1>Gesti贸n de Leads</h1>\n    \n    <div class=\"metrics-cards\">\n      <div class=\"metric-card\">\n        <h3>Total Leads</h3>\n        <p class=\"number\">{{ metrics.totalLeads }}</p>\n      </div>\n      <div class=\"metric-card\">\n        <h3>Nuevos (30 d铆as)</h3>\n        <p class=\"number\">{{ metrics.newLeads }}</p>\n      </div>\n      <div class=\"metric-card\">\n        <h3>Activos</h3>\n        <p class=\"number\">{{ metrics.activeLeads }}</p>\n      </div>\n      <div class=\"metric-card\">\n        <h3>Conversi贸n</h3>\n        <p class=\"number\">{{ metrics.conversionRate }}%</p>\n      </div>\n    </div>\n    \n    <div class=\"filters\">\n      <input v-model=\"filters.search\" placeholder=\"Buscar por nombre o email...\" />\n      <select v-model=\"filters.status\">\n        <option value=\"\">Todos los estados</option>\n        <option value=\"new\">Nuevo</option>\n        <option value=\"contacted\">Contactado</option>\n        <option value=\"qualified\">Calificado</option>\n        <option value=\"negotiating\">En negociaci贸n</option>\n        <option value=\"closed\">Cerrado</option>\n      </select>\n    </div>\n    \n    <table class=\"leads-table\">\n      <thead>\n        <tr>\n          <th>Nombre</th>\n          <th>Email</th>\n          <th>Tel茅fono</th>\n          <th>Estado</th>\n          <th>ltima Actividad</th>\n          <th>Acciones</th>\n        </tr>\n      </thead>\n      <tbody>\n        <tr v-for=\"lead in filteredLeads\" :key=\"lead.id\">\n          <td>{{ lead.first_name }} {{ lead.last_name }}</td>\n          <td>{{ lead.email }}</td>\n          <td>{{ lead.phone }}</td>\n          <td>{{ lead.status }}</td>\n          <td>{{ formatDate(lead.last_activity_date) }}</td>\n          <td class=\"actions\">\n            <button @click=\"viewLeadDetails(lead.id)\" class=\"btn-view\">Ver</button>\n            <button @click=\"editLead(lead.id)\" class=\"btn-edit\">Editar</button>\n          </td>\n        </tr>\n      </tbody>\n    </table>\n  </div>\n</template>\n\n<script setup>\nimport { ref, computed, onMounted } from 'vue'\n\nconst leads = ref([])\nconst metrics = ref({\n  totalLeads: 0,\n  newLeads: 0,\n  activeLeads: 0,\n  conversionRate: 0\n})\nconst filters = ref({\n  search: '',\n  status: ''\n})\n\nonMounted(async () => {\n  await fetchLeads()\n  await fetchMetrics()\n})\n\nasync function fetchLeads() {\n  const { data } = await useFetch('/api/leads')\n  leads.value = data.value || []\n}\n\nasync function fetchMetrics() {\n  const { data } = await useFetch('/api/leads/metrics')\n  metrics.value = data.value || {\n    totalLeads: 0,\n    newLeads: 0,\n    activeLeads: 0,\n    conversionRate: 0\n  }\n}\n\nconst filteredLeads = computed(() => {\n  return leads.value.filter(lead => {\n    const fullName = `${lead.first_name} ${lead.last_name}`.toLowerCase()\n    const matchesSearch = !filters.value.search || \n      fullName.includes(filters.value.search.toLowerCase()) ||\n      (lead.email && lead.email.toLowerCase().includes(filters.value.search.toLowerCase()))\n    \n    const matchesStatus = !filters.value.status || lead.status === filters.value.status\n    \n    return matchesSearch && matchesStatus\n  })\n})\n\nfunction viewLeadDetails(id) {\n  navigateTo(`/dashboard/leads/${id}`)\n}\n\nfunction editLead(id) {\n  navigateTo(`/dashboard/leads/${id}/edit`)\n}\n\nfunction formatDate(dateString) {\n  if (!dateString) return 'N/A'\n  return new Date(dateString).toLocaleDateString()\n}\n</script>\n```\n\n```python\n# FastAPI endpoint para actividad de leads\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom typing import List, Optional\nfrom datetime import datetime, timedelta\n\nrouter = APIRouter(prefix=\"/api/leads\", tags=[\"leads\"])\n\n@router.get(\"/activity/{lead_id}\")\nasync def get_lead_activity(\n    lead_id: int,\n    tenant_id: str = Depends(tenant_middleware),\n    current_user: User = Depends(get_current_user)\n):\n    # Verificar permisos\n    if not current_user.is_realtor:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n    \n    # Obtener actividad del lead\n    viewed_properties = await database.get_viewed_properties(tenant_id, lead_id)\n    favorite_properties = await database.get_favorite_properties(tenant_id, lead_id)\n    scheduled_showings = await database.get_scheduled_showings(tenant_id, lead_id)\n    \n    return {\n        \"viewed_properties\": viewed_properties,\n        \"favorite_properties\": favorite_properties,\n        \"scheduled_showings\": scheduled_showings\n    }\n```",
        "testStrategy": "Probar la creaci贸n, actualizaci贸n y eliminaci贸n de leads. Verificar el seguimiento correcto de la actividad del cliente. Comprobar la funcionalidad de filtrado y b煤squeda de leads. Validar las m茅tricas y visualizaciones del dashboard. Probar la integraci贸n con el sistema de propiedades y visitas.",
        "priority": "high",
        "dependencies": [
          27,
          28,
          29
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 34,
        "title": "Implementar Sistema de Agendamiento de Visitas (Showings)",
        "description": "Desarrollar la funcionalidad para que los clientes puedan agendar visitas a propiedades y los realtors puedan gestionar estas solicitudes.",
        "details": "Crear un sistema de calendario para mostrar disponibilidad. Implementar formulario de solicitud de visita para clientes. Desarrollar panel de gesti贸n de visitas para realtors con confirmaci贸n, reprogramaci贸n y cancelaci贸n. Enviar notificaciones por email para confirmaciones y recordatorios.\n\n```javascript\n// components/PropertyShowingScheduler.vue\n<template>\n  <div class=\"showing-scheduler\">\n    <h3>Agendar Visita</h3>\n    \n    <div class=\"date-picker\">\n      <h4>Seleccione una fecha:</h4>\n      <div class=\"calendar\">\n        <!-- Componente de calendario -->\n        <DatePicker v-model=\"selectedDate\" :disabled-dates=\"disabledDates\" />\n      </div>\n    </div>\n    \n    <div v-if=\"selectedDate\" class=\"time-slots\">\n      <h4>Horarios disponibles:</h4>\n      <div class=\"slots-grid\">\n        <button \n          v-for=\"slot in availableTimeSlots\" \n          :key=\"slot.time\"\n          :class=\"['time-slot', { selected: selectedTimeSlot === slot.time }]\"\n          @click=\"selectedTimeSlot = slot.time\"\n          :disabled=\"!slot.available\"\n        >\n          {{ formatTime(slot.time) }}\n        </button>\n      </div>\n    </div>\n    \n    <div v-if=\"selectedTimeSlot\" class=\"contact-form\">\n      <h4>Informaci贸n de contacto:</h4>\n      <div v-if=\"!isLoggedIn\">\n        <p>Complete sus datos para agendar la visita:</p>\n        <div class=\"form-group\">\n          <label>Nombre:</label>\n          <input v-model=\"contactInfo.name\" type=\"text\" required />\n        </div>\n        <div class=\"form-group\">\n          <label>Email:</label>\n          <input v-model=\"contactInfo.email\" type=\"email\" required />\n        </div>\n        <div class=\"form-group\">\n          <label>Tel茅fono:</label>\n          <input v-model=\"contactInfo.phone\" type=\"tel\" required />\n        </div>\n      </div>\n      <div v-else>\n        <p>Se utilizar谩 la informaci贸n de su perfil para la visita.</p>\n      </div>\n      <div class=\"form-group\">\n        <label>Comentarios (opcional):</label>\n        <textarea v-model=\"contactInfo.comments\"></textarea>\n      </div>\n    </div>\n    \n    <button \n      @click=\"scheduleShowing\" \n      class=\"btn-schedule\" \n      :disabled=\"!canSchedule\"\n    >\n      Agendar Visita\n    </button>\n  </div>\n</template>\n\n<script setup>\nimport { ref, computed, onMounted } from 'vue'\nimport DatePicker from 'vue-datepicker-next'\nimport 'vue-datepicker-next/index.css'\n\nconst props = defineProps({\n  propertyId: {\n    type: Number,\n    required: true\n  }\n})\n\nconst selectedDate = ref(null)\nconst selectedTimeSlot = ref(null)\nconst availableTimeSlots = ref([])\nconst disabledDates = ref([])\nconst isLoggedIn = ref(false)\nconst contactInfo = ref({\n  name: '',\n  email: '',\n  phone: '',\n  comments: ''\n})\n\nonMounted(async () => {\n  // Verificar si el usuario est谩 logueado\n  const user = useSupabaseUser()\n  isLoggedIn.value = !!user.value\n  \n  if (isLoggedIn.value) {\n    // Cargar informaci贸n del usuario\n    const { data } = await useFetch('/api/user/profile')\n    if (data.value) {\n      contactInfo.value.name = `${data.value.first_name} ${data.value.last_name}`\n      contactInfo.value.email = data.value.email\n      contactInfo.value.phone = data.value.phone || ''\n    }\n  }\n  \n  // Cargar fechas no disponibles\n  await fetchDisabledDates()\n})\n\nasync function fetchDisabledDates() {\n  const { data } = await useFetch(`/api/properties/${props.propertyId}/unavailable-dates`)\n  disabledDates.value = data.value?.map(date => new Date(date)) || []\n}\n\nwatch(selectedDate, async (newDate) => {\n  if (newDate) {\n    await fetchAvailableTimeSlots(newDate)\n  } else {\n    availableTimeSlots.value = []\n    selectedTimeSlot.value = null\n  }\n})\n\nasync function fetchAvailableTimeSlots(date) {\n  const formattedDate = date.toISOString().split('T')[0]\n  const { data } = await useFetch(`/api/properties/${props.propertyId}/available-slots?date=${formattedDate}`)\n  availableTimeSlots.value = data.value || []\n}\n\nconst canSchedule = computed(() => {\n  if (!selectedDate.value || !selectedTimeSlot.value) return false\n  \n  if (!isLoggedIn.value) {\n    return !!contactInfo.value.name && !!contactInfo.value.email && !!contactInfo.value.phone\n  }\n  \n  return true\n})\n\nasync function scheduleShowing() {\n  if (!canSchedule.value) return\n  \n  const showingData = {\n    property_id: props.propertyId,\n    date: selectedDate.value.toISOString().split('T')[0],\n    time: selectedTimeSlot.value,\n    contact_info: contactInfo.value\n  }\n  \n  const { data, error } = await useFetch('/api/showings', {\n    method: 'POST',\n    body: showingData\n  })\n  \n  if (error.value) {\n    alert('Error al agendar la visita. Por favor, int茅ntelo de nuevo.')\n    return\n  }\n  \n  alert('隆Visita agendada con 茅xito! Recibir谩 un email de confirmaci贸n.')\n  // Resetear formulario\n  selectedDate.value = null\n  selectedTimeSlot.value = null\n  if (!isLoggedIn.value) {\n    contactInfo.value = {\n      name: '',\n      email: '',\n      phone: '',\n      comments: ''\n    }\n  } else {\n    contactInfo.value.comments = ''\n  }\n}\n\nfunction formatTime(timeString) {\n  const [hours, minutes] = timeString.split(':')\n  return `${hours}:${minutes}`\n}\n</script>\n```",
        "testStrategy": "Probar el flujo completo de agendamiento de visitas. Verificar la correcta visualizaci贸n de disponibilidad y bloqueo de fechas/horas no disponibles. Comprobar la creaci贸n, confirmaci贸n, reprogramaci贸n y cancelaci贸n de visitas. Validar el env铆o de notificaciones por email. Probar la integraci贸n con el sistema de leads.",
        "priority": "medium",
        "dependencies": [
          28,
          29,
          33
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "Implementar Sistema de Seguimiento de Transacciones",
        "description": "Desarrollar la funcionalidad para que los realtors puedan hacer seguimiento de las transacciones inmobiliarias en diferentes etapas.",
        "details": "Crear un sistema de pipeline visual para transacciones. Implementar etapas personalizables por tipo de transacci贸n (compra, venta, alquiler). Desarrollar funcionalidad para mover transacciones entre etapas. Integrar con el sistema de leads y propiedades.\n\n```javascript\n// pages/dashboard/transactions/index.vue\n<template>\n  <div class=\"transactions-dashboard\">\n    <h1>Pipeline de Transacciones</h1>\n    \n    <div class=\"transaction-type-selector\">\n      <button \n        v-for=\"type in transactionTypes\" \n        :key=\"type.value\"\n        :class=\"['type-btn', { active: selectedType === type.value }]\"\n        @click=\"selectedType = type.value\"\n      >\n        {{ type.label }}\n      </button>\n    </div>\n    \n    <div class=\"pipeline-container\">\n      <div \n        v-for=\"stage in stagesForSelectedType\" \n        :key=\"stage.id\"\n        class=\"pipeline-stage\"\n      >\n        <div class=\"stage-header\">\n          <h3>{{ stage.name }}</h3>\n          <span class=\"count\">{{ transactionsInStage(stage.id).length }}</span>\n        </div>\n        \n        <div class=\"stage-body\">\n          <div \n            v-for=\"transaction in transactionsInStage(stage.id)\" \n            :key=\"transaction.id\"\n            class=\"transaction-card\"\n            draggable=\"true\"\n            @dragstart=\"dragStart(transaction, $event)\"\n          >\n            <div class=\"card-header\">\n              <h4>{{ transaction.property.title }}</h4>\n              <span class=\"price\">{{ formatCurrency(transaction.property.price) }}</span>\n            </div>\n            <div class=\"card-body\">\n              <p class=\"client\">Cliente: {{ transaction.lead.first_name }} {{ transaction.lead.last_name }}</p>\n              <p class=\"date\">Actualizado: {{ formatDate(transaction.updated_at) }}</p>\n            </div>\n            <div class=\"card-actions\">\n              <button @click=\"viewTransactionDetails(transaction.id)\" class=\"btn-view\">\n                Ver Detalles\n              </button>\n            </div>\n          </div>\n          \n          <div \n            class=\"drop-zone\" \n            @dragover.prevent\n            @drop=\"dropTransaction($event, stage.id)\"\n          ></div>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport { ref, computed, onMounted } from 'vue'\n\nconst transactions = ref([])\nconst stages = ref([])\nconst selectedType = ref('purchase') // Valor por defecto\nconst draggedTransaction = ref(null)\n\nconst transactionTypes = [\n  { value: 'purchase', label: 'Compra' },\n  { value: 'sale', label: 'Venta' },\n  { value: 'rental', label: 'Alquiler' },\n  { value: 'temp_rental', label: 'Alquiler Temporario' }\n]\n\nonMounted(async () => {\n  await Promise.all([\n    fetchTransactions(),\n    fetchStages()\n  ])\n})\n\nasync function fetchTransactions() {\n  const { data } = await useFetch(`/api/transactions?type=${selectedType.value}`)\n  transactions.value = data.value || []\n}\n\nasync function fetchStages() {\n  const { data } = await useFetch('/api/transaction-stages')\n  stages.value = data.value || []\n}\n\nconst stagesForSelectedType = computed(() => {\n  return stages.value.filter(stage => stage.transaction_type === selectedType.value)\n})\n\nfunction transactionsInStage(stageId) {\n  return transactions.value.filter(transaction => transaction.stage_id === stageId)\n}\n\nfunction dragStart(transaction, event) {\n  draggedTransaction.value = transaction\n  event.dataTransfer.effectAllowed = 'move'\n}\n\nasync function dropTransaction(event, stageId) {\n  if (!draggedTransaction.value) return\n  \n  const transactionId = draggedTransaction.value.id\n  \n  // Actualizar en la UI primero para una experiencia m谩s fluida\n  const transactionIndex = transactions.value.findIndex(t => t.id === transactionId)\n  if (transactionIndex !== -1) {\n    transactions.value[transactionIndex].stage_id = stageId\n    transactions.value[transactionIndex].updated_at = new Date().toISOString()\n  }\n  \n  // Luego actualizar en el servidor\n  await useFetch(`/api/transactions/${transactionId}/stage`, {\n    method: 'PUT',\n    body: { stage_id: stageId }\n  })\n  \n  draggedTransaction.value = null\n}\n\nfunction viewTransactionDetails(id) {\n  navigateTo(`/dashboard/transactions/${id}`)\n}\n\nfunction formatCurrency(value) {\n  return new Intl.NumberFormat('es-ES', {\n    style: 'currency',\n    currency: 'EUR'\n  }).format(value)\n}\n\nfunction formatDate(dateString) {\n  return new Date(dateString).toLocaleDateString()\n}\n\nwatch(selectedType, async () => {\n  await fetchTransactions()\n})\n</script>\n```\n\n```python\n# Esquema de base de datos para transacciones\n'''\nCREATE TABLE tenant_{tenant_id}.transaction_stages (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    transaction_type VARCHAR(50) NOT NULL,\n    position INT NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE tenant_{tenant_id}.transactions (\n    id SERIAL PRIMARY KEY,\n    lead_id INT REFERENCES tenant_{tenant_id}.leads(id),\n    property_id INT REFERENCES tenant_{tenant_id}.properties(id),\n    transaction_type VARCHAR(50) NOT NULL,\n    stage_id INT REFERENCES tenant_{tenant_id}.transaction_stages(id),\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n'''\n```",
        "testStrategy": "Probar la creaci贸n y gesti贸n de transacciones. Verificar la funcionalidad de arrastrar y soltar para mover transacciones entre etapas. Comprobar la personalizaci贸n de etapas por tipo de transacci贸n. Validar la integraci贸n con el sistema de leads y propiedades. Probar la visualizaci贸n del pipeline en diferentes dispositivos.",
        "priority": "medium",
        "dependencies": [
          27,
          28,
          33
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 36,
        "title": "Implementar Sistema de Favoritos y Alertas de Precio",
        "description": "Desarrollar la funcionalidad para que los clientes puedan guardar propiedades como favoritas y recibir alertas de cambios de precio.",
        "details": "Crear sistema de favoritos para usuarios registrados. Implementar funcionalidad para guardar/eliminar favoritos. Desarrollar sistema de alertas de precio que notifique a los usuarios cuando una propiedad favorita cambie de precio. Integrar con n8n para la automatizaci贸n de alertas.\n\n```javascript\n// components/PropertyFavoriteButton.vue\n<template>\n  <button \n    @click=\"toggleFavorite\" \n    :class=\"['favorite-btn', { active: isFavorite }]\"\n    :disabled=\"isLoading\"\n  >\n    <span v-if=\"isFavorite\" class=\"icon\">わ</span>\n    <span v-else class=\"icon\"></span>\n    <span class=\"text\">{{ isFavorite ? 'Guardado' : 'Guardar' }}</span>\n  </button>\n</template>\n\n<script setup>\nimport { ref, onMounted } from 'vue'\n\nconst props = defineProps({\n  propertyId: {\n    type: Number,\n    required: true\n  }\n})\n\nconst isFavorite = ref(false)\nconst isLoading = ref(false)\nconst isLoggedIn = ref(false)\n\nonMounted(async () => {\n  const user = useSupabaseUser()\n  isLoggedIn.value = !!user.value\n  \n  if (isLoggedIn.value) {\n    await checkFavoriteStatus()\n  }\n})\n\nasync function checkFavoriteStatus() {\n  isLoading.value = true\n  const { data } = await useFetch(`/api/favorites/check/${props.propertyId}`)\n  isFavorite.value = data.value?.is_favorite || false\n  isLoading.value = false\n}\n\nasync function toggleFavorite() {\n  if (!isLoggedIn.value) {\n    // Redirigir a login si no est谩 autenticado\n    const currentPath = window.location.pathname\n    navigateTo(`/login?redirect=${encodeURIComponent(currentPath)}`)\n    return\n  }\n  \n  isLoading.value = true\n  \n  if (isFavorite.value) {\n    // Eliminar de favoritos\n    await useFetch(`/api/favorites/${props.propertyId}`, {\n      method: 'DELETE'\n    })\n    isFavorite.value = false\n  } else {\n    // A帽adir a favoritos\n    await useFetch('/api/favorites', {\n      method: 'POST',\n      body: { property_id: props.propertyId }\n    })\n    isFavorite.value = true\n  }\n  \n  isLoading.value = false\n}\n</script>\n```\n\n```python\n# FastAPI endpoints para favoritos y alertas\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom typing import List\n\nrouter = APIRouter(prefix=\"/api/favorites\", tags=[\"favorites\"])\n\n@router.post(\"/\")\nasync def add_favorite(\n    favorite: FavoriteCreate,\n    tenant_id: str = Depends(tenant_middleware),\n    current_user: User = Depends(get_current_user)\n):\n    if not current_user:\n        raise HTTPException(status_code=401, detail=\"Not authenticated\")\n    \n    # A帽adir a favoritos\n    await database.add_favorite(tenant_id, current_user.id, favorite.property_id)\n    \n    # Configurar alerta de precio si est谩 habilitada\n    if favorite.enable_price_alert:\n        await setup_price_alert(tenant_id, current_user.id, favorite.property_id)\n    \n    return {\"status\": \"success\"}\n\n@router.delete(\"/{property_id}\")\nasync def remove_favorite(\n    property_id: int,\n    tenant_id: str = Depends(tenant_middleware),\n    current_user: User = Depends(get_current_user)\n):\n    if not current_user:\n        raise HTTPException(status_code=401, detail=\"Not authenticated\")\n    \n    # Eliminar de favoritos\n    await database.remove_favorite(tenant_id, current_user.id, property_id)\n    \n    # Eliminar alerta de precio si existe\n    await remove_price_alert(tenant_id, current_user.id, property_id)\n    \n    return {\"status\": \"success\"}\n\nasync def setup_price_alert(tenant_id: str, user_id: str, property_id: int):\n    # Obtener informaci贸n actual de la propiedad\n    property_info = await database.get_property(tenant_id, property_id)\n    \n    # Registrar en la tabla de alertas\n    await database.create_price_alert(tenant_id, user_id, property_id, property_info.price)\n    \n    # Configurar workflow en n8n\n    # Esto podr铆a ser una llamada a la API de n8n o un registro en una tabla que n8n monitorea\n    pass\n```\n\n```sql\n-- Esquema para favoritos y alertas de precio\nCREATE TABLE tenant_{tenant_id}.favorites (\n    id SERIAL PRIMARY KEY,\n    user_id UUID REFERENCES auth.users(id),\n    property_id INT REFERENCES tenant_{tenant_id}.properties(id),\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    UNIQUE(user_id, property_id)\n);\n\nCREATE TABLE tenant_{tenant_id}.price_alerts (\n    id SERIAL PRIMARY KEY,\n    user_id UUID REFERENCES auth.users(id),\n    property_id INT REFERENCES tenant_{tenant_id}.properties(id),\n    original_price DECIMAL(12,2) NOT NULL,\n    last_checked_price DECIMAL(12,2) NOT NULL,\n    is_active BOOLEAN DEFAULT TRUE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    UNIQUE(user_id, property_id)\n);\n```",
        "testStrategy": "Probar la funcionalidad de a帽adir y eliminar favoritos. Verificar que los usuarios no autenticados sean redirigidos al login. Comprobar que las alertas de precio se configuren correctamente. Probar el env铆o de notificaciones cuando cambie el precio de una propiedad favorita. Validar la integraci贸n con n8n para la automatizaci贸n de alertas.",
        "priority": "medium",
        "dependencies": [
          28,
          29,
          32
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 37,
        "title": "Implementar Carga Masiva de Propiedades",
        "description": "Desarrollar la funcionalidad para que los realtors puedan importar m煤ltiples propiedades mediante archivos CSV o integraci贸n con APIs externas.",
        "details": "Crear interfaz para carga de archivos CSV. Implementar validaci贸n y mapeo de campos. Desarrollar proceso de importaci贸n en segundo plano. Proporcionar feedback sobre el progreso y resultados de la importaci贸n. Implementar integraci贸n con APIs externas de propiedades.\n\n```javascript\n// pages/dashboard/properties/import.vue\n<template>\n  <div class=\"property-import\">\n    <h1>Importaci贸n de Propiedades</h1>\n    \n    <div class=\"import-options\">\n      <div class=\"option-card\">\n        <h3>Importar desde CSV</h3>\n        <p>Sube un archivo CSV con tus propiedades.</p>\n        <div class=\"file-upload\">\n          <input \n            type=\"file\" \n            ref=\"fileInput\"\n            accept=\".csv\"\n            @change=\"handleFileUpload\"\n          />\n          <button @click=\"triggerFileInput\" class=\"btn-upload\">\n            Seleccionar Archivo\n          </button>\n          <span v-if=\"selectedFile\">{{ selectedFile.name }}</span>\n        </div>\n        <div v-if=\"selectedFile\" class=\"field-mapping\">\n          <h4>Mapeo de Campos</h4>\n          <p>Asigna las columnas de tu CSV a los campos de propiedades:</p>\n          \n          <div v-for=\"field in requiredFields\" :key=\"field.key\" class=\"field-map\">\n            <label>{{ field.label }}:</label>\n            <select v-model=\"fieldMapping[field.key]\">\n              <option value=\"\">-- Seleccionar columna --</option>\n              <option v-for=\"column in csvColumns\" :key=\"column\" :value=\"column\">\n                {{ column }}\n              </option>\n            </select>\n          </div>\n          \n          <button @click=\"startImport\" class=\"btn-start-import\" :disabled=\"!canStartImport\">\n            Iniciar Importaci贸n\n          </button>\n        </div>\n      </div>\n      \n      <div class=\"option-card\">\n        <h3>Importar desde API Externa</h3>\n        <p>Conecta con una API externa para importar propiedades.</p>\n        <div class=\"api-selection\">\n          <select v-model=\"selectedApi\">\n            <option value=\"\">-- Seleccionar API --</option>\n            <option v-for=\"api in availableApis\" :key=\"api.id\" :value=\"api.id\">\n              {{ api.name }}\n            </option>\n          </select>\n        </div>\n        <div v-if=\"selectedApi\" class=\"api-config\">\n          <h4>Configuraci贸n de API</h4>\n          <!-- Campos espec铆ficos seg煤n la API seleccionada -->\n          <div v-if=\"selectedApi === 'idealista'\" class=\"api-fields\">\n            <div class=\"field\">\n              <label>API Key:</label>\n              <input type=\"password\" v-model=\"apiConfig.apiKey\" />\n            </div>\n            <div class=\"field\">\n              <label>Secret:</label>\n              <input type=\"password\" v-model=\"apiConfig.secret\" />\n            </div>\n          </div>\n          \n          <button @click=\"startApiImport\" class=\"btn-start-import\" :disabled=\"!canStartApiImport\">\n            Iniciar Importaci贸n desde API\n          </button>\n        </div>\n      </div>\n    </div>\n    \n    <div v-if=\"importStatus\" class=\"import-status\">\n      <h3>Estado de la Importaci贸n</h3>\n      <div class=\"progress-bar\">\n        <div \n          class=\"progress\" \n          :style=\"{ width: `${importStatus.progress}%` }\"\n        ></div>\n      </div>\n      <p class=\"status-text\">{{ importStatus.message }}</p>\n      <div v-if=\"importStatus.completed\" class=\"import-results\">\n        <p>Total procesadas: {{ importStatus.total }}</p>\n        <p>Importadas correctamente: {{ importStatus.success }}</p>\n        <p>Con errores: {{ importStatus.errors }}</p>\n        <button v-if=\"importStatus.errors > 0\" @click=\"downloadErrorLog\" class=\"btn-download\">\n          Descargar Log de Errores\n        </button>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport { ref, computed, onMounted } from 'vue'\nimport Papa from 'papaparse'\n\nconst fileInput = ref(null)\nconst selectedFile = ref(null)\nconst csvColumns = ref([])\nconst fieldMapping = ref({})\nconst importStatus = ref(null)\nconst selectedApi = ref('')\nconst apiConfig = ref({\n  apiKey: '',\n  secret: ''\n})\n\nconst requiredFields = [\n  { key: 'title', label: 'T铆tulo' },\n  { key: 'description', label: 'Descripci贸n' },\n  { key: 'property_type', label: 'Tipo de Propiedad' },\n  { key: 'price', label: 'Precio' },\n  { key: 'address', label: 'Direcci贸n' },\n  { key: 'city', label: 'Ciudad' },\n  { key: 'bedrooms', label: 'Habitaciones' },\n  { key: 'bathrooms', label: 'Ba帽os' },\n  { key: 'area', label: 'Superficie (m虏)' },\n  { key: 'status', label: 'Estado' }\n]\n\nconst availableApis = [\n  { id: 'idealista', name: 'Idealista' },\n  { id: 'fotocasa', name: 'Fotocasa' },\n  { id: 'habitaclia', name: 'Habitaclia' }\n]\n\nfunction triggerFileInput() {\n  fileInput.value.click()\n}\n\nfunction handleFileUpload(event) {\n  const file = event.target.files[0]\n  if (!file) return\n  \n  selectedFile.value = file\n  \n  // Parsear las primeras filas para obtener las columnas\n  Papa.parse(file, {\n    preview: 1,\n    header: true,\n    complete: function(results) {\n      csvColumns.value = Object.keys(results.data[0])\n      \n      // Intentar mapeo autom谩tico por nombres similares\n      requiredFields.forEach(field => {\n        const matchingColumn = csvColumns.value.find(column => \n          column.toLowerCase().includes(field.key.toLowerCase())\n        )\n        if (matchingColumn) {\n          fieldMapping.value[field.key] = matchingColumn\n        }\n      })\n    }\n  })\n}\n\nconst canStartImport = computed(() => {\n  if (!selectedFile.value) return false\n  \n  // Verificar que todos los campos requeridos est茅n mapeados\n  return requiredFields.every(field => !!fieldMapping.value[field.key])\n})\n\nconst canStartApiImport = computed(() => {\n  if (!selectedApi.value) return false\n  \n  if (selectedApi.value === 'idealista') {\n    return !!apiConfig.value.apiKey && !!apiConfig.value.secret\n  }\n  \n  return true\n})\n\nasync function startImport() {\n  if (!canStartImport.value) return\n  \n  // Iniciar estado de importaci贸n\n  importStatus.value = {\n    progress: 0,\n    message: 'Iniciando importaci贸n...',\n    completed: false,\n    total: 0,\n    success: 0,\n    errors: 0\n  }\n  \n  // Crear FormData para enviar el archivo y el mapeo\n  const formData = new FormData()\n  formData.append('file', selectedFile.value)\n  formData.append('mapping', JSON.stringify(fieldMapping.value))\n  \n  // Iniciar la importaci贸n\n  const response = await fetch('/api/properties/import/csv', {\n    method: 'POST',\n    body: formData\n  })\n  \n  const { job_id } = await response.json()\n  \n  // Iniciar polling para seguimiento del progreso\n  pollImportStatus(job_id)\n}\n\nasync function startApiImport() {\n  if (!canStartApiImport.value) return\n  \n  // Iniciar estado de importaci贸n\n  importStatus.value = {\n    progress: 0,\n    message: 'Iniciando importaci贸n desde API...',\n    completed: false,\n    total: 0,\n    success: 0,\n    errors: 0\n  }\n  \n  // Enviar configuraci贸n de API\n  const response = await fetch(`/api/properties/import/api/${selectedApi.value}`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(apiConfig.value)\n  })\n  \n  const { job_id } = await response.json()\n  \n  // Iniciar polling para seguimiento del progreso\n  pollImportStatus(job_id)\n}\n\nasync function pollImportStatus(jobId) {\n  const intervalId = setInterval(async () => {\n    const response = await fetch(`/api/import-jobs/${jobId}`)\n    const status = await response.json()\n    \n    importStatus.value = status\n    \n    if (status.completed) {\n      clearInterval(intervalId)\n    }\n  }, 2000)\n}\n\nasync function downloadErrorLog() {\n  if (!importStatus.value || !importStatus.value.job_id) return\n  \n  const response = await fetch(`/api/import-jobs/${importStatus.value.job_id}/errors`)\n  const blob = await response.blob()\n  \n  const url = window.URL.createObjectURL(blob)\n  const a = document.createElement('a')\n  a.href = url\n  a.download = `import-errors-${new Date().toISOString().split('T')[0]}.csv`\n  document.body.appendChild(a)\n  a.click()\n  a.remove()\n}\n</script>\n```\n\n```python\n# FastAPI endpoints para importaci贸n de propiedades\nfrom fastapi import APIRouter, UploadFile, File, Form, BackgroundTasks\nfrom typing import Dict, Any\nimport json\nimport csv\nimport io\n\nrouter = APIRouter(prefix=\"/api/properties\", tags=[\"properties\"])\n\n@router.post(\"/import/csv\")\nasync def import_properties_csv(\n    background_tasks: BackgroundTasks,\n    file: UploadFile = File(...),\n    mapping: str = Form(...),\n    tenant_id: str = Depends(tenant_middleware),\n    current_user: User = Depends(get_current_user)\n):\n    if not current_user.is_realtor:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n    \n    # Parsear el mapeo de campos\n    field_mapping = json.loads(mapping)\n    \n    # Crear un job de importaci贸n\n    job_id = await database.create_import_job(tenant_id, current_user.id, 'csv')\n    \n    # Iniciar tarea en segundo plano\n    background_tasks.add_task(\n        process_csv_import, \n        tenant_id, \n        job_id, \n        await file.read(), \n        field_mapping\n    )\n    \n    return {\"job_id\": job_id}\n\nasync def process_csv_import(tenant_id: str, job_id: int, file_content: bytes, field_mapping: Dict[str, str]):\n    # Actualizar estado del job\n    await database.update_import_job(tenant_id, job_id, {\n        \"status\": \"processing\",\n        \"progress\": 0,\n        \"message\": \"Procesando archivo CSV...\"\n    })\n    \n    # Procesar el CSV\n    csv_file = io.StringIO(file_content.decode('utf-8'))\n    reader = csv.DictReader(csv_file)\n    rows = list(reader)\n    total_rows = len(rows)\n    \n    success_count = 0\n    error_count = 0\n    errors = []\n    \n    for i, row in enumerate(rows):\n        try:\n            # Mapear campos seg煤n la configuraci贸n\n            property_data = {}\n            for field_key, csv_column in field_mapping.items():\n                property_data[field_key] = row[csv_column]\n            \n            # Validar y convertir tipos de datos\n            if 'price' in property_data:\n                property_data['price'] = float(property_data['price'].replace(',', '.'))\n            if 'bedrooms' in property_data:\n                property_data['bedrooms'] = int(property_data['bedrooms'])\n            if 'bathrooms' in property_data:\n                property_data['bathrooms'] = float(property_data['bathrooms'].replace(',', '.'))\n            if 'area' in property_data:\n                property_data['area'] = float(property_data['area'].replace(',', '.'))\n            \n            # Crear la propiedad\n            await database.create_property(tenant_id, property_data)\n            success_count += 1\n        except Exception as e:\n            error_count += 1\n            errors.append({\n                \"row\": i + 1,\n                \"data\": row,\n                \"error\": str(e)\n            })\n        \n        # Actualizar progreso\n        progress = int((i + 1) / total_rows * 100)\n        await database.update_import_job(tenant_id, job_id, {\n            \"progress\": progress,\n            \"message\": f\"Procesando {i + 1} de {total_rows}...\"\n        })\n    \n    # Actualizar estado final\n    await database.update_import_job(tenant_id, job_id, {\n        \"status\": \"completed\",\n        \"progress\": 100,\n        \"message\": \"Importaci贸n completada\",\n        \"completed\": True,\n        \"total\": total_rows,\n        \"success\": success_count,\n        \"errors\": error_count,\n        \"error_details\": errors\n    })\n```",
        "testStrategy": "Probar la carga y procesamiento de archivos CSV con diferentes formatos. Verificar el mapeo correcto de campos. Comprobar el manejo de errores durante la importaci贸n. Validar el seguimiento del progreso en tiempo real. Probar la integraci贸n con APIs externas para importaci贸n de propiedades.",
        "priority": "medium",
        "dependencies": [
          28,
          31
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 38,
        "title": "Implementar B煤squeda Sem谩ntica con Base de Datos Vectorial",
        "description": "Desarrollar un sistema de b煤squeda avanzada utilizando Qdrant como base de datos vectorial para b煤squedas sem谩nticas de propiedades.",
        "details": "Integrar Qdrant para almacenar embeddings de propiedades. Implementar generaci贸n de embeddings a partir de descripciones y caracter铆sticas de propiedades. Desarrollar API de b煤squeda sem谩ntica que permita encontrar propiedades similares o basadas en consultas en lenguaje natural.\n\n```python\n# Integraci贸n con Qdrant para b煤squeda sem谩ntica\nfrom fastapi import APIRouter, Depends, Query\nfrom typing import List, Optional\nimport numpy as np\nfrom qdrant_client import QdrantClient\nfrom qdrant_client.http.models import Distance, VectorParams, PointStruct\nfrom sentence_transformers import SentenceTransformer\n\nrouter = APIRouter(prefix=\"/api/search\", tags=[\"search\"])\n\n# Inicializar el modelo de embeddings y cliente Qdrant\nmodel = SentenceTransformer('paraphrase-multilingual-MiniLM-L12-v2')\nqdrant_client = QdrantClient(host=\"qdrant\", port=6333)\n\n# Asegurar que la colecci贸n existe\ndef ensure_collection(tenant_id: str):\n    collection_name = f\"properties_{tenant_id}\"\n    collections = qdrant_client.get_collections().collections\n    collection_names = [c.name for c in collections]\n    \n    if collection_name not in collection_names:\n        qdrant_client.create_collection(\n            collection_name=collection_name,\n            vectors_config=VectorParams(size=384, distance=Distance.COSINE)\n        )\n    \n    return collection_name\n\n# Generar embedding para una propiedad\ndef generate_property_embedding(property_data):\n    # Crear texto que represente la propiedad\n    text = f\"{property_data['title']}. {property_data['description']}. \"\n    text += f\"Tipo: {property_data['property_type']}. \"\n    text += f\"Ubicaci贸n: {property_data['city']}, {property_data.get('state', '')}. \"\n    text += f\"{property_data.get('bedrooms', 0)} habitaciones, {property_data.get('bathrooms', 0)} ba帽os. \"\n    text += f\"{property_data.get('area', 0)} m虏.\"\n    \n    # Generar embedding\n    embedding = model.encode(text)\n    return embedding\n\n# Endpoint para indexar una propiedad\n@router.post(\"/index-property/{property_id}\")\nasync def index_property(\n    property_id: int,\n    tenant_id: str = Depends(tenant_middleware),\n    current_user: User = Depends(get_current_user)\n):\n    if not current_user.is_realtor:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n    \n    # Obtener datos de la propiedad\n    property_data = await database.get_property(tenant_id, property_id)\n    if not property_data:\n        raise HTTPException(status_code=404, detail=\"Property not found\")\n    \n    # Generar embedding\n    embedding = generate_property_embedding(property_data)\n    \n    # Asegurar que la colecci贸n existe\n    collection_name = ensure_collection(tenant_id)\n    \n    # Indexar la propiedad\n    qdrant_client.upsert(\n        collection_name=collection_name,\n        points=[\n            PointStruct(\n                id=property_id,\n                vector=embedding.tolist(),\n                payload={\n                    \"property_id\": property_id,\n                    \"title\": property_data[\"title\"],\n                    \"price\": float(property_data[\"price\"]),\n                    \"property_type\": property_data[\"property_type\"],\n                    \"bedrooms\": property_data.get(\"bedrooms\"),\n                    \"bathrooms\": property_data.get(\"bathrooms\"),\n                    \"area\": property_data.get(\"area\")\n                }\n            )\n        ]\n    )\n    \n    return {\"status\": \"indexed\"}\n\n# Endpoint para b煤squeda sem谩ntica\n@router.get(\"/semantic\")\nasync def semantic_search(\n    query: str,\n    limit: int = Query(10, ge=1, le=100),\n    tenant_id: str = Depends(tenant_middleware)\n):\n    # Generar embedding de la consulta\n    query_embedding = model.encode(query)\n    \n    # Asegurar que la colecci贸n existe\n    collection_name = ensure_collection(tenant_id)\n    \n    # Realizar b煤squeda\n    search_result = qdrant_client.search(\n        collection_name=collection_name,\n        query_vector=query_embedding.tolist(),\n        limit=limit\n    )\n    \n    # Obtener IDs de propiedades encontradas\n    property_ids = [hit.id for hit in search_result]\n    \n    # Obtener datos completos de las propiedades\n    properties = await database.get_properties_by_ids(tenant_id, property_ids)\n    \n    # Ordenar propiedades seg煤n el orden de los resultados de b煤squeda\n    property_dict = {prop[\"id\"]: prop for prop in properties}\n    ordered_properties = [property_dict[pid] for pid in property_ids if pid in property_dict]\n    \n    return ordered_properties\n\n# Endpoint para propiedades similares\n@router.get(\"/similar/{property_id}\")\nasync def similar_properties(\n    property_id: int,\n    limit: int = Query(5, ge=1, le=20),\n    tenant_id: str = Depends(tenant_middleware)\n):\n    # Obtener datos de la propiedad\n    property_data = await database.get_property(tenant_id, property_id)\n    if not property_data:\n        raise HTTPException(status_code=404, detail=\"Property not found\")\n    \n    # Generar embedding\n    embedding = generate_property_embedding(property_data)\n    \n    # Asegurar que la colecci贸n existe\n    collection_name = ensure_collection(tenant_id)\n    \n    # Realizar b煤squeda de similares\n    search_result = qdrant_client.search(\n        collection_name=collection_name,\n        query_vector=embedding.tolist(),\n        limit=limit + 1  # +1 porque la propiedad misma ser谩 el primer resultado\n    )\n    \n    # Filtrar la propiedad original y obtener IDs\n    property_ids = [hit.id for hit in search_result if hit.id != property_id]\n    \n    # Obtener datos completos de las propiedades\n    properties = await database.get_properties_by_ids(tenant_id, property_ids)\n    \n    return properties\n```\n\n```javascript\n// components/SemanticSearchBar.vue\n<template>\n  <div class=\"semantic-search\">\n    <div class=\"search-input\">\n      <input \n        v-model=\"searchQuery\" \n        type=\"text\" \n        placeholder=\"Describe la propiedad que buscas...\"\n        @keyup.enter=\"performSearch\"\n      />\n      <button @click=\"performSearch\" class=\"btn-search\">\n        <span class=\"icon\"></span>\n      </button>\n    </div>\n    \n    <div v-if=\"isSearching\" class=\"loading\">\n      Buscando...\n    </div>\n    \n    <div v-if=\"searchResults.length > 0\" class=\"search-results\">\n      <h3>Resultados de b煤squeda</h3>\n      <div class=\"results-grid\">\n        <PropertyCard \n          v-for=\"property in searchResults\" \n          :key=\"property.id\"\n          :property=\"property\"\n        />\n      </div>\n    </div>\n    \n    <div v-if=\"searchPerformed && searchResults.length === 0\" class=\"no-results\">\n      No se encontraron propiedades que coincidan con tu b煤squeda.\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\nimport PropertyCard from '~/components/PropertyCard.vue'\n\nconst searchQuery = ref('')\nconst searchResults = ref([])\nconst isSearching = ref(false)\nconst searchPerformed = ref(false)\n\nasync function performSearch() {\n  if (!searchQuery.value.trim()) return\n  \n  isSearching.value = true\n  searchPerformed.value = true\n  \n  try {\n    const { data } = await useFetch(`/api/search/semantic?query=${encodeURIComponent(searchQuery.value)}`)\n    searchResults.value = data.value || []\n  } catch (error) {\n    console.error('Error en b煤squeda sem谩ntica:', error)\n    searchResults.value = []\n  } finally {\n    isSearching.value = false\n  }\n}\n</script>\n```",
        "testStrategy": "Probar la generaci贸n de embeddings para diferentes tipos de propiedades. Verificar la indexaci贸n correcta en Qdrant. Comprobar la b煤squeda sem谩ntica con diferentes consultas en lenguaje natural. Validar la b煤squeda de propiedades similares. Probar el rendimiento con un gran n煤mero de propiedades indexadas.",
        "priority": "medium",
        "dependencies": [
          28,
          31,
          32
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 39,
        "title": "Configurar Despliegue con Docker Swarm y Portainer",
        "description": "Implementar la infraestructura de despliegue utilizando Docker Swarm para orquestaci贸n de contenedores y Portainer para gesti贸n.",
        "details": "Crear archivos Docker Compose para definir servicios. Configurar Docker Swarm para alta disponibilidad. Implementar Portainer para gesti贸n visual de contenedores. Configurar redes y vol煤menes persistentes. Implementar estrategias de despliegue continuo.\n\n```yaml\n# docker-compose.yml\nversion: '3.8'\n\nservices:\n  # Frontend (Nuxt.js)\n  frontend:\n    build:\n      context: ./frontend\n      dockerfile: Dockerfile\n    image: ${REGISTRY}/plataforma-inmobiliaria-frontend:${TAG:-latest}\n    deploy:\n      replicas: 2\n      update_config:\n        parallelism: 1\n        delay: 10s\n        order: start-first\n      restart_policy:\n        condition: on-failure\n    networks:\n      - frontend-network\n    depends_on:\n      - api\n\n  # API Backend (FastAPI)\n  api:\n    build:\n      context: ./backend\n      dockerfile: Dockerfile\n    image: ${REGISTRY}/plataforma-inmobiliaria-api:${TAG:-latest}\n    deploy:\n      replicas: 2\n      update_config:\n        parallelism: 1\n        delay: 10s\n        order: start-first\n      restart_policy:\n        condition: on-failure\n    environment:\n      - DATABASE_URL=postgresql://postgres:${POSTGRES_PASSWORD}@postgres:5432/plataforma_inmobiliaria\n      - SUPABASE_URL=${SUPABASE_URL}\n      - SUPABASE_KEY=${SUPABASE_KEY}\n      - QDRANT_HOST=qdrant\n      - QDRANT_PORT=6333\n    networks:\n      - backend-network\n      - frontend-network\n    depends_on:\n      - postgres\n      - qdrant\n\n  # PostgreSQL\n  postgres:\n    image: postgres:14-alpine\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n    environment:\n      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}\n      - POSTGRES_DB=plataforma_inmobiliaria\n    deploy:\n      placement:\n        constraints:\n          - node.role == manager\n      restart_policy:\n        condition: on-failure\n    networks:\n      - backend-network\n\n  # Qdrant (Vector Database)\n  qdrant:\n    image: qdrant/qdrant:latest\n    volumes:\n      - qdrant-data:/qdrant/storage\n    deploy:\n      placement:\n        constraints:\n          - node.role == manager\n      restart_policy:\n        condition: on-failure\n    networks:\n      - backend-network\n\n  # n8n (Workflow Automation)\n  n8n:\n    image: n8nio/n8n:latest\n    environment:\n      - N8N_BASIC_AUTH_ACTIVE=true\n      - N8N_BASIC_AUTH_USER=${N8N_USER}\n      - N8N_BASIC_AUTH_PASSWORD=${N8N_PASSWORD}\n      - N8N_HOST=${N8N_HOST}\n      - N8N_PORT=5678\n      - N8N_PROTOCOL=https\n      - NODE_ENV=production\n      - WEBHOOK_URL=https://${N8N_HOST}\n    volumes:\n      - n8n-data:/home/node/.n8n\n    deploy:\n      placement:\n        constraints:\n          - node.role == manager\n      restart_policy:\n        condition: on-failure\n    networks:\n      - backend-network\n      - frontend-network\n\n  # Nginx (Reverse Proxy)\n  nginx:\n    image: nginx:alpine\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - ./nginx/conf.d:/etc/nginx/conf.d\n      - ./nginx/ssl:/etc/nginx/ssl\n      - ./nginx/www:/var/www/html\n    deploy:\n      replicas: 2\n      update_config:\n        parallelism: 1\n        delay: 10s\n      restart_policy:\n        condition: on-failure\n    networks:\n      - frontend-network\n\n  # Portainer (Container Management)\n  portainer:\n    image: portainer/portainer-ce:latest\n    command: -H unix:///var/run/docker.sock\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n      - portainer-data:/data\n    ports:\n      - \"9000:9000\"\n    deploy:\n      placement:\n        constraints:\n          - node.role == manager\n      restart_policy:\n        condition: on-failure\n    networks:\n      - frontend-network\n\nnetworks:\n  frontend-network:\n    driver: overlay\n  backend-network:\n    driver: overlay\n\nvolumes:\n  postgres-data:\n  qdrant-data:\n  n8n-data:\n  portainer-data:\n```\n\n```bash\n#!/bin/bash\n# deploy.sh - Script para desplegar la aplicaci贸n en Docker Swarm\n\n# Cargar variables de entorno\nset -a\nsource .env\nset +a\n\n# Inicializar Docker Swarm si no est谩 inicializado\nif ! docker info | grep -q \"Swarm: active\"; then\n  echo \"Inicializando Docker Swarm...\"\n  docker swarm init --advertise-addr $(hostname -I | awk '{print $1}')\nfi\n\n# Crear redes si no existen\nif ! docker network ls | grep -q \"frontend-network\"; then\n  echo \"Creando red frontend-network...\"\n  docker network create --driver overlay frontend-network\nfi\n\nif ! docker network ls | grep -q \"backend-network\"; then\n  echo \"Creando red backend-network...\"\n  docker network create --driver overlay backend-network\nfi\n\n# Desplegar stack\necho \"Desplegando stack de aplicaci贸n...\"\ndocker stack deploy -c docker-compose.yml plataforma-inmobiliaria\n\necho \"Despliegue completado. Accede a Portainer en http://$(hostname -I | awk '{print $1}'):9000\"\n```",
        "testStrategy": "Probar el despliegue en entornos de desarrollo, staging y producci贸n. Verificar la correcta configuraci贸n de redes y vol煤menes. Comprobar la alta disponibilidad y balanceo de carga. Validar la gesti贸n de contenedores a trav茅s de Portainer. Probar estrategias de actualizaci贸n y rollback.",
        "priority": "high",
        "dependencies": [
          28,
          29
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 40,
        "title": "Desplegar Frontend de Nuxt.js a Vercel",
        "description": "Configurar y desplegar la aplicaci贸n frontend de Nuxt.js a un entorno de producci贸n/staging utilizando la plataforma Vercel para garantizar un despliegue continuo y eficiente.",
        "details": "1. Crear una cuenta en Vercel si a煤n no se tiene una.\n\n2. Instalar la CLI de Vercel para facilitar el despliegue:\n```bash\nnpm install -g vercel\n```\n\n3. Configurar el proyecto Nuxt.js para producci贸n:\n   - Asegurar que el archivo `nuxt.config.js` est茅 correctamente configurado para producci贸n\n   - Verificar las variables de entorno necesarias\n\n```javascript\n// nuxt.config.js\nexport default defineNuxtConfig({\n  // Configuraci贸n para producci贸n\n  app: {\n    head: {\n      title: 'Plataforma Inmobiliaria',\n      meta: [\n        { charset: 'utf-8' },\n        { name: 'viewport', content: 'width=device-width, initial-scale=1' },\n        { hid: 'description', name: 'description', content: 'Plataforma inmobiliaria multi-tenant' }\n      ]\n    }\n  },\n  // Asegurar que las variables de entorno est茅n configuradas\n  runtimeConfig: {\n    public: {\n      apiBaseUrl: process.env.API_BASE_URL || 'http://localhost:8000',\n      supabaseUrl: process.env.SUPABASE_URL,\n      supabaseKey: process.env.SUPABASE_KEY\n    }\n  }\n})\n```\n\n4. Crear un archivo `vercel.json` en la ra铆z del proyecto para configurar el despliegue:\n```json\n{\n  \"version\": 2,\n  \"builds\": [\n    {\n      \"src\": \"nuxt.config.js\",\n      \"use\": \"@nuxtjs/vercel-builder\",\n      \"config\": {\n        \"serverFiles\": [\"server/**\"]\n      }\n    }\n  ],\n  \"routes\": [\n    {\n      \"src\": \"/api/(.*)\",\n      \"dest\": \"/api/$1\"\n    },\n    {\n      \"src\": \"/(.*)\",\n      \"dest\": \"/\"\n    }\n  ],\n  \"env\": {\n    \"NUXT_PUBLIC_API_BASE_URL\": \"@api_base_url\",\n    \"NUXT_PUBLIC_SUPABASE_URL\": \"@supabase_url\",\n    \"NUXT_PUBLIC_SUPABASE_KEY\": \"@supabase_key\"\n  }\n}\n```\n\n5. Configurar variables de entorno en Vercel:\n   - Desde el dashboard de Vercel, a帽adir las variables de entorno necesarias\n   - Alternativamente, usar la CLI:\n   ```bash\n   vercel secrets add api_base_url \"https://api.plataforma-inmobiliaria.com\"\n   vercel secrets add supabase_url \"https://your-project.supabase.co\"\n   vercel secrets add supabase_key \"your-supabase-key\"\n   ```\n\n6. Desplegar a Vercel:\n   - Iniciar sesi贸n en Vercel desde la CLI:\n   ```bash\n   vercel login\n   ```\n   - Desplegar el proyecto:\n   ```bash\n   vercel\n   ```\n   - Para despliegue a producci贸n:\n   ```bash\n   vercel --prod\n   ```\n\n7. Configurar dominios personalizados:\n   - Desde el dashboard de Vercel, a帽adir dominios personalizados para cada tenant\n   - Configurar los registros DNS necesarios\n   - Verificar la propiedad del dominio\n\n8. Configurar integraci贸n continua:\n   - Conectar el repositorio de GitHub/GitLab/Bitbucket a Vercel\n   - Configurar despliegues autom谩ticos en cada push a la rama principal\n   - Configurar previews para pull requests\n\n9. Optimizar para rendimiento:\n   - Habilitar compresi贸n Brotli/Gzip\n   - Configurar Edge CDN\n   - Habilitar cach茅 para recursos est谩ticos",
        "testStrategy": "1. Verificar el despliegue inicial:\n   - Comprobar que la aplicaci贸n se despliega correctamente en Vercel\n   - Verificar que todas las rutas funcionan como se espera\n   - Comprobar que los estilos y assets se cargan correctamente\n\n2. Probar la configuraci贸n de variables de entorno:\n   - Verificar que la aplicaci贸n puede conectarse correctamente a la API\n   - Comprobar que la autenticaci贸n con Supabase funciona en el entorno de producci贸n\n   - Validar que las variables sensibles no se exponen en el frontend\n\n3. Validar la funcionalidad multi-tenant:\n   - Probar el acceso a trav茅s de diferentes subdominios/dominios\n   - Verificar que cada tenant ve solo sus datos correspondientes\n   - Comprobar que la resoluci贸n de tenants funciona correctamente en producci贸n\n\n4. Realizar pruebas de rendimiento:\n   - Ejecutar Lighthouse para evaluar rendimiento, accesibilidad y SEO\n   - Verificar tiempos de carga en diferentes dispositivos y conexiones\n   - Comprobar que la aplicaci贸n cumple con los est谩ndares de Core Web Vitals\n\n5. Probar la integraci贸n continua:\n   - Realizar un cambio menor y verificar que se despliega autom谩ticamente\n   - Comprobar que los despliegues de preview funcionan correctamente para pull requests\n   - Verificar que los rollbacks funcionan en caso de problemas\n\n6. Validar la seguridad:\n   - Verificar que los headers de seguridad est谩n correctamente configurados\n   - Comprobar que HTTPS est谩 habilitado y funciona correctamente\n   - Realizar un escaneo b谩sico de seguridad\n\n7. Probar la escalabilidad:\n   - Simular carga para verificar el comportamiento bajo tr谩fico elevado\n   - Comprobar que el CDN funciona correctamente para recursos est谩ticos\n   - Verificar que la aplicaci贸n se escala autom谩ticamente seg煤n la demanda",
        "status": "pending",
        "dependencies": [
          29
        ],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-05T17:28:50.476Z",
      "updated": "2025-07-26T14:39:33.518Z",
      "description": "Tasks for master context"
    }
  }
}
{
  "master": {
    "tasks": [
      {
        "id": 25,
        "title": "Configurar Arquitectura Multi-Tenant Base",
        "description": "Establecer la estructura base para soportar múltiples tenants (realtors) con aislamiento de datos y configuración.",
        "details": "Implementar un sistema de identificación de tenants basado en subdominios y dominios personalizados. Crear un esquema de base de datos que soporte el aislamiento de datos por tenant. Configurar middleware para la resolución de tenants basado en la URL.\n\n```python\n# Ejemplo de middleware para resolución de tenant en FastAPI\nfrom fastapi import Request, Depends\n\nasync def tenant_middleware(request: Request):\n    host = request.headers.get('host', '')\n    # Extraer tenant_id del subdominio o buscar en la tabla de dominios personalizados\n    tenant_id = extract_tenant_from_host(host)\n    request.state.tenant_id = tenant_id\n    return tenant_id\n\n# Esquema de base de datos para tenants\n'''\nCREATE TABLE tenants (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    subdomain VARCHAR(255) UNIQUE NOT NULL,\n    custom_domain VARCHAR(255) UNIQUE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n'''\n```",
        "testStrategy": "Crear tests unitarios para la resolución de tenants basada en subdominios y dominios personalizados. Verificar el correcto aislamiento de datos entre tenants. Probar la creación, actualización y eliminación de tenants.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Tenant Identification Strategy",
            "description": "Define and implement a method to identify tenants using subdomains and custom domains, ensuring each request is correctly mapped to its tenant.",
            "dependencies": [],
            "details": "Establish rules for extracting tenant identifiers from incoming URLs, considering both subdomain and custom domain scenarios. Document the mapping logic and edge cases.",
            "status": "done",
            "testStrategy": "Create unit tests to verify tenant extraction from various URL formats, including edge cases and invalid domains."
          },
          {
            "id": 2,
            "title": "Implement Tenant Resolution Middleware",
            "description": "Develop middleware to resolve and attach the tenant context to each request based on the identification strategy.",
            "dependencies": [
              "25.1"
            ],
            "details": "Integrate middleware into the application stack (e.g., FastAPI) that uses the identification logic to set the tenant context for downstream processing.",
            "status": "done",
            "testStrategy": "Test middleware with simulated requests to ensure correct tenant context is set for all supported domain patterns."
          },
          {
            "id": 3,
            "title": "Design Multi-Tenant Database Schema",
            "description": "Create a database schema that supports data isolation per tenant, using schemas or tenant-specific tables as appropriate.",
            "dependencies": [
              "25.1"
            ],
            "details": "Evaluate and select a multi-tenant database pattern (e.g., shared schema with tenant_id column, separate schemas per tenant) based on isolation and scalability requirements. Implement the chosen schema in the database.",
            "status": "done",
            "testStrategy": "Verify that data for one tenant is inaccessible to others through direct queries and application logic. Test schema creation and migration processes."
          },
          {
            "id": 4,
            "title": "Implement Tenant Management Operations",
            "description": "Develop functionality to create, update, and delete tenants, ensuring proper setup and teardown of associated resources.",
            "dependencies": [
              "25.3"
            ],
            "details": "Automate the provisioning of database schemas or tables and domain mappings when a new tenant is created. Ensure cleanup on tenant deletion.",
            "status": "pending",
            "testStrategy": "Test tenant lifecycle operations, verifying that resources are correctly created and removed, and that no data leakage occurs between tenants."
          },
          {
            "id": 5,
            "title": "Validate Data Isolation and Tenant Resolution",
            "description": "Conduct comprehensive testing to ensure strict data isolation and correct tenant resolution across all layers.",
            "dependencies": [
              "25.2",
              "25.3",
              "25.4"
            ],
            "details": "Perform integration and security tests to confirm that requests are always processed in the correct tenant context and that no cross-tenant data access is possible.",
            "status": "pending",
            "testStrategy": "Simulate concurrent requests from multiple tenants, attempt unauthorized data access, and verify that isolation and resolution mechanisms are robust."
          }
        ]
      },
      {
        "id": 26,
        "title": "Implementar Sistema de Autenticación con Supabase",
        "description": "Configurar Supabase para la autenticación y gestión de usuarios, tanto para realtors (tenants) como para usuarios finales.",
        "details": "Integrar Supabase Auth para manejar el registro, inicio de sesión y gestión de usuarios. Crear dos niveles de usuarios: realtors (administradores) y usuarios finales (clientes). Implementar JWT para la autenticación en la API.\n\n```javascript\n// Ejemplo de configuración de Supabase en Nuxt.js\n// nuxt.config.js\nexport default {\n  modules: ['@nuxtjs/supabase'],\n  supabase: {\n    url: process.env.SUPABASE_URL,\n    key: process.env.SUPABASE_KEY,\n    redirect: {\n      login: '/login',\n      callback: '/confirm',\n      exclude: ['/'],\n    },\n  }\n}\n\n// Ejemplo de uso en componente Vue\nconst { auth } = useSupabaseClient()\nconst user = useSupabaseUser()\n\nconst login = async () => {\n  const { error } = await auth.signInWithPassword({\n    email: email.value,\n    password: password.value,\n  })\n}\n```",
        "testStrategy": "Probar flujos de registro, inicio de sesión, recuperación de contraseña y cierre de sesión. Verificar la correcta asignación de roles y permisos. Probar la integración con la API principal mediante tokens JWT.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Diseñar e Implementar Esquema de Base de Datos PostgreSQL",
        "description": "Crear el esquema de base de datos relacional en PostgreSQL para almacenar propiedades, usuarios, transacciones y configuraciones de tenants.",
        "details": "Diseñar tablas para propiedades, usuarios, transacciones, configuraciones de tenant, y relaciones entre ellas. Implementar esquemas separados por tenant para garantizar el aislamiento de datos. Configurar índices para optimizar consultas frecuentes.\n\n```sql\n-- Esquema base para cada tenant\nCREATE SCHEMA tenant_{tenant_id};\n\n-- Tabla de propiedades\nCREATE TABLE tenant_{tenant_id}.properties (\n    id SERIAL PRIMARY KEY,\n    title VARCHAR(255) NOT NULL,\n    description TEXT,\n    property_type VARCHAR(50) NOT NULL,\n    price DECIMAL(12,2) NOT NULL,\n    address VARCHAR(255) NOT NULL,\n    city VARCHAR(100) NOT NULL,\n    state VARCHAR(100),\n    zip_code VARCHAR(20),\n    latitude DECIMAL(10,8),\n    longitude DECIMAL(11,8),\n    bedrooms INT,\n    bathrooms DECIMAL(3,1),\n    area DECIMAL(10,2),\n    status VARCHAR(50) NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Tabla de clientes (leads)\nCREATE TABLE tenant_{tenant_id}.leads (\n    id SERIAL PRIMARY KEY,\n    user_id UUID REFERENCES auth.users(id),\n    first_name VARCHAR(100),\n    last_name VARCHAR(100),\n    email VARCHAR(255),\n    phone VARCHAR(50),\n    status VARCHAR(50),\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Tabla de transacciones\nCREATE TABLE tenant_{tenant_id}.transactions (\n    id SERIAL PRIMARY KEY,\n    lead_id INT REFERENCES tenant_{tenant_id}.leads(id),\n    property_id INT REFERENCES tenant_{tenant_id}.properties(id),\n    transaction_type VARCHAR(50) NOT NULL,\n    stage VARCHAR(50) NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n```",
        "testStrategy": "Verificar la integridad referencial entre tablas. Probar consultas complejas para asegurar rendimiento. Validar el aislamiento de datos entre tenants. Realizar pruebas de carga para evaluar el rendimiento con grandes volúmenes de datos.",
        "priority": "high",
        "dependencies": [
          25
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Desarrollar API RESTful con FastAPI",
        "description": "Implementar la API principal utilizando FastAPI para manejar todas las operaciones CRUD y lógica de negocio.",
        "details": "Crear endpoints RESTful para gestionar propiedades, usuarios, transacciones y configuraciones de tenant. Implementar validación de datos con Pydantic. Configurar autenticación JWT y autorización basada en roles. Documentar la API con Swagger/OpenAPI.\n\n```python\nfrom fastapi import FastAPI, Depends, HTTPException, status\nfrom typing import List, Optional\nfrom pydantic import BaseModel\nfrom datetime import datetime\n\napp = FastAPI(title=\"Plataforma Inmobiliaria API\")\n\nclass PropertyBase(BaseModel):\n    title: str\n    description: Optional[str] = None\n    property_type: str\n    price: float\n    address: str\n    city: str\n    state: Optional[str] = None\n    zip_code: Optional[str] = None\n    latitude: Optional[float] = None\n    longitude: Optional[float] = None\n    bedrooms: Optional[int] = None\n    bathrooms: Optional[float] = None\n    area: Optional[float] = None\n    status: str\n\nclass PropertyCreate(PropertyBase):\n    pass\n\nclass Property(PropertyBase):\n    id: int\n    created_at: datetime\n    updated_at: datetime\n\n    class Config:\n        orm_mode = True\n\n@app.post(\"/properties/\", response_model=Property)\nasync def create_property(\n    property: PropertyCreate, \n    tenant_id: str = Depends(tenant_middleware),\n    current_user: User = Depends(get_current_user)\n):\n    # Verificar permisos del usuario\n    if not current_user.is_realtor:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n    \n    # Crear propiedad en la base de datos del tenant\n    db_property = await database.create_property(tenant_id, property)\n    return db_property\n```",
        "testStrategy": "Crear tests unitarios para cada endpoint. Implementar tests de integración para flujos completos. Verificar la correcta validación de datos y manejo de errores. Probar la autenticación y autorización para diferentes roles de usuario.",
        "priority": "high",
        "dependencies": [
          26,
          27
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Implementar Frontend Base con Nuxt.js",
        "description": "Configurar el proyecto Nuxt.js con TailwindCSS y Pinia para el frontend, estableciendo la estructura base para portales de cliente y dashboard de realtor.",
        "details": "Configurar Nuxt.js 3 con Vue 3, TailwindCSS para estilos y Pinia para gestión de estado. Implementar enrutamiento dinámico basado en tenant. Crear layouts separados para portal de cliente y dashboard de realtor.\n\n```bash\n# Instalación de dependencias\nnpm init nuxt-app plataforma-inmobiliaria\ncd plataforma-inmobiliaria\nnpm install @nuxtjs/tailwindcss pinia @pinia/nuxt @nuxtjs/supabase\n```\n\n```javascript\n// nuxt.config.js\nexport default defineNuxtConfig({\n  modules: [\n    '@nuxtjs/tailwindcss',\n    '@pinia/nuxt',\n    '@nuxtjs/supabase'\n  ],\n  app: {\n    head: {\n      title: 'Plataforma Inmobiliaria',\n      meta: [\n        { charset: 'utf-8' },\n        { name: 'viewport', content: 'width=device-width, initial-scale=1' }\n      ]\n    }\n  },\n  runtimeConfig: {\n    public: {\n      apiBaseUrl: process.env.API_BASE_URL || 'http://localhost:8000'\n    }\n  }\n})\n```\n\n```javascript\n// store/tenant.js\nimport { defineStore } from 'pinia'\n\nexport const useTenantStore = defineStore('tenant', {\n  state: () => ({\n    currentTenant: null,\n    branding: {\n      logo: null,\n      primaryColor: '#3B82F6',\n      secondaryColor: '#1E3A8A'\n    }\n  }),\n  actions: {\n    async fetchTenantInfo(tenantId) {\n      // Obtener información del tenant desde la API\n      const { data } = await useFetch(`/api/tenants/${tenantId}`)\n      this.currentTenant = data.value\n      this.branding = data.value.branding\n    }\n  }\n})\n```",
        "testStrategy": "Realizar pruebas de componentes con Vue Test Utils. Verificar la correcta renderización de layouts según el tenant. Probar la integración con Pinia para la gestión de estado. Validar la responsividad en diferentes dispositivos.",
        "priority": "high",
        "dependencies": [
          25,
          26
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Desarrollar Sistema de Personalización de Branding por Tenant",
        "description": "Implementar la funcionalidad que permite a cada realtor personalizar su portal con logo, colores y estilos propios.",
        "details": "Crear un sistema de temas dinámicos basado en la configuración del tenant. Implementar un panel de configuración en el dashboard del realtor para subir logo y seleccionar colores. Almacenar la configuración en la base de datos y aplicarla dinámicamente en el frontend.\n\n```javascript\n// components/TenantBrandingConfig.vue\n<template>\n  <div class=\"branding-config\">\n    <h2>Personalización de Marca</h2>\n    <div class=\"form-group\">\n      <label>Logo</label>\n      <input type=\"file\" @change=\"uploadLogo\" accept=\"image/*\" />\n      <img v-if=\"branding.logo\" :src=\"branding.logo\" class=\"preview\" />\n    </div>\n    <div class=\"form-group\">\n      <label>Color Primario</label>\n      <input type=\"color\" v-model=\"branding.primaryColor\" />\n    </div>\n    <div class=\"form-group\">\n      <label>Color Secundario</label>\n      <input type=\"color\" v-model=\"branding.secondaryColor\" />\n    </div>\n    <button @click=\"saveBranding\" class=\"btn-save\">Guardar Cambios</button>\n  </div>\n</template>\n\n<script setup>\nimport { ref, onMounted } from 'vue'\nimport { useTenantStore } from '~/store/tenant'\n\nconst tenantStore = useTenantStore()\nconst branding = ref({\n  logo: null,\n  primaryColor: '#3B82F6',\n  secondaryColor: '#1E3A8A'\n})\n\nonMounted(async () => {\n  // Cargar configuración actual\n  branding.value = { ...tenantStore.branding }\n})\n\nasync function uploadLogo(event) {\n  const file = event.target.files[0]\n  if (!file) return\n  \n  // Subir imagen a almacenamiento\n  const formData = new FormData()\n  formData.append('logo', file)\n  const { data } = await useFetch('/api/tenants/branding/logo', {\n    method: 'POST',\n    body: formData\n  })\n  \n  branding.value.logo = data.value.url\n}\n\nasync function saveBranding() {\n  await useFetch('/api/tenants/branding', {\n    method: 'PUT',\n    body: branding.value\n  })\n  \n  // Actualizar store\n  tenantStore.branding = { ...branding.value }\n}\n</script>\n```\n\n```css\n/* CSS dinámico basado en configuración del tenant */\n:root {\n  --primary-color: v-bind('tenantStore.branding.primaryColor');\n  --secondary-color: v-bind('tenantStore.branding.secondaryColor');\n}\n```",
        "testStrategy": "Probar la carga y almacenamiento de logos. Verificar la aplicación correcta de colores personalizados. Validar que los cambios se reflejen inmediatamente en el portal del cliente. Probar con diferentes combinaciones de colores y formatos de imagen.",
        "priority": "medium",
        "dependencies": [
          25,
          29
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "Implementar Gestión de Propiedades en Dashboard de Realtor",
        "description": "Desarrollar la interfaz y funcionalidad CRUD para que los realtors puedan gestionar sus propiedades desde el dashboard.",
        "details": "Crear formularios para añadir, editar y eliminar propiedades. Implementar carga de imágenes múltiples. Desarrollar vista de listado con filtros y búsqueda. Integrar con la API para operaciones CRUD.\n\n```javascript\n// pages/dashboard/properties/index.vue\n<template>\n  <div class=\"properties-dashboard\">\n    <h1>Gestión de Propiedades</h1>\n    <div class=\"actions\">\n      <button @click=\"navigateTo('/dashboard/properties/new')\" class=\"btn-primary\">\n        Añadir Propiedad\n      </button>\n    </div>\n    \n    <div class=\"filters\">\n      <input v-model=\"filters.search\" placeholder=\"Buscar...\" />\n      <select v-model=\"filters.status\">\n        <option value=\"\">Todos los estados</option>\n        <option value=\"active\">Activa</option>\n        <option value=\"pending\">Pendiente</option>\n        <option value=\"sold\">Vendida</option>\n        <option value=\"rented\">Alquilada</option>\n      </select>\n      <select v-model=\"filters.type\">\n        <option value=\"\">Todos los tipos</option>\n        <option value=\"house\">Casa</option>\n        <option value=\"apartment\">Apartamento</option>\n        <option value=\"land\">Terreno</option>\n      </select>\n    </div>\n    \n    <table class=\"properties-table\">\n      <thead>\n        <tr>\n          <th>ID</th>\n          <th>Título</th>\n          <th>Tipo</th>\n          <th>Precio</th>\n          <th>Estado</th>\n          <th>Acciones</th>\n        </tr>\n      </thead>\n      <tbody>\n        <tr v-for=\"property in filteredProperties\" :key=\"property.id\">\n          <td>{{ property.id }}</td>\n          <td>{{ property.title }}</td>\n          <td>{{ property.property_type }}</td>\n          <td>{{ formatCurrency(property.price) }}</td>\n          <td>{{ property.status }}</td>\n          <td class=\"actions\">\n            <button @click=\"editProperty(property.id)\" class=\"btn-edit\">Editar</button>\n            <button @click=\"confirmDelete(property.id)\" class=\"btn-delete\">Eliminar</button>\n          </td>\n        </tr>\n      </tbody>\n    </table>\n  </div>\n</template>\n\n<script setup>\nimport { ref, computed, onMounted } from 'vue'\n\nconst properties = ref([])\nconst filters = ref({\n  search: '',\n  status: '',\n  type: ''\n})\n\nonMounted(async () => {\n  await fetchProperties()\n})\n\nasync function fetchProperties() {\n  const { data } = await useFetch('/api/properties')\n  properties.value = data.value || []\n}\n\nconst filteredProperties = computed(() => {\n  return properties.value.filter(property => {\n    const matchesSearch = !filters.value.search || \n      property.title.toLowerCase().includes(filters.value.search.toLowerCase()) ||\n      property.address.toLowerCase().includes(filters.value.search.toLowerCase())\n    \n    const matchesStatus = !filters.value.status || property.status === filters.value.status\n    const matchesType = !filters.value.type || property.property_type === filters.value.type\n    \n    return matchesSearch && matchesStatus && matchesType\n  })\n})\n\nfunction editProperty(id) {\n  navigateTo(`/dashboard/properties/${id}/edit`)\n}\n\nasync function confirmDelete(id) {\n  if (confirm('¿Está seguro de que desea eliminar esta propiedad?')) {\n    await useFetch(`/api/properties/${id}`, { method: 'DELETE' })\n    await fetchProperties()\n  }\n}\n\nfunction formatCurrency(value) {\n  return new Intl.NumberFormat('es-ES', {\n    style: 'currency',\n    currency: 'EUR'\n  }).format(value)\n}\n</script>\n```",
        "testStrategy": "Probar todas las operaciones CRUD de propiedades. Verificar la validación de formularios y manejo de errores. Comprobar la funcionalidad de filtrado y búsqueda. Probar la carga y visualización de imágenes múltiples. Verificar que los cambios se reflejen correctamente en el portal del cliente.",
        "priority": "high",
        "dependencies": [
          28,
          29
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Desarrollar Visualización de Propiedades en Mapa Interactivo",
        "description": "Implementar un mapa interactivo como vista principal del portal del cliente, mostrando las propiedades disponibles con filtros y búsqueda.",
        "details": "Integrar una biblioteca de mapas (como Mapbox o Leaflet) para mostrar propiedades georreferenciadas. Implementar clustering para mejorar el rendimiento con muchas propiedades. Añadir filtros interactivos y búsqueda. Mostrar información básica de la propiedad al hacer clic en un marcador.\n\n```javascript\n// components/PropertyMap.vue\n<template>\n  <div class=\"map-container\">\n    <div class=\"filters-panel\">\n      <input v-model=\"filters.search\" placeholder=\"Buscar por ubicación...\" />\n      <div class=\"price-range\">\n        <label>Precio:</label>\n        <input type=\"number\" v-model=\"filters.minPrice\" placeholder=\"Mínimo\" />\n        <input type=\"number\" v-model=\"filters.maxPrice\" placeholder=\"Máximo\" />\n      </div>\n      <div class=\"property-type\">\n        <label>Tipo:</label>\n        <div v-for=\"type in propertyTypes\" :key=\"type.value\">\n          <input type=\"checkbox\" :value=\"type.value\" v-model=\"filters.types\" />\n          <span>{{ type.label }}</span>\n        </div>\n      </div>\n      <button @click=\"applyFilters\" class=\"btn-apply\">Aplicar Filtros</button>\n    </div>\n    \n    <div id=\"map\" ref=\"mapContainer\" class=\"map\"></div>\n    \n    <div v-if=\"selectedProperty\" class=\"property-preview\">\n      <img :src=\"selectedProperty.mainImage\" alt=\"Property\" />\n      <h3>{{ selectedProperty.title }}</h3>\n      <p class=\"price\">{{ formatCurrency(selectedProperty.price) }}</p>\n      <p class=\"address\">{{ selectedProperty.address }}</p>\n      <div class=\"features\">\n        <span>{{ selectedProperty.bedrooms }} hab</span>\n        <span>{{ selectedProperty.bathrooms }} baños</span>\n        <span>{{ selectedProperty.area }} m²</span>\n      </div>\n      <button @click=\"viewPropertyDetails(selectedProperty.id)\" class=\"btn-view\">\n        Ver Detalles\n      </button>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport { ref, onMounted, watch } from 'vue'\nimport mapboxgl from 'mapbox-gl'\nimport 'mapbox-gl/dist/mapbox-gl.css'\n\nconst mapContainer = ref(null)\nconst map = ref(null)\nconst properties = ref([])\nconst selectedProperty = ref(null)\nconst filters = ref({\n  search: '',\n  minPrice: null,\n  maxPrice: null,\n  types: []\n})\n\nconst propertyTypes = [\n  { value: 'house', label: 'Casa' },\n  { value: 'apartment', label: 'Apartamento' },\n  { value: 'land', label: 'Terreno' }\n]\n\nonMounted(async () => {\n  mapboxgl.accessToken = 'YOUR_MAPBOX_TOKEN'\n  \n  map.value = new mapboxgl.Map({\n    container: mapContainer.value,\n    style: 'mapbox://styles/mapbox/streets-v11',\n    center: [-3.7038, 40.4168], // Madrid como centro inicial\n    zoom: 12\n  })\n  \n  map.value.on('load', async () => {\n    await fetchProperties()\n    addPropertiesToMap()\n  })\n})\n\nasync function fetchProperties() {\n  const queryParams = new URLSearchParams()\n  if (filters.value.search) queryParams.append('search', filters.value.search)\n  if (filters.value.minPrice) queryParams.append('min_price', filters.value.minPrice)\n  if (filters.value.maxPrice) queryParams.append('max_price', filters.value.maxPrice)\n  if (filters.value.types.length) queryParams.append('types', filters.value.types.join(','))\n  \n  const { data } = await useFetch(`/api/properties?${queryParams.toString()}`)\n  properties.value = data.value || []\n}\n\nfunction addPropertiesToMap() {\n  // Limpiar marcadores existentes\n  const markers = document.querySelectorAll('.mapboxgl-marker')\n  markers.forEach(marker => marker.remove())\n  \n  // Añadir nuevos marcadores\n  properties.value.forEach(property => {\n    if (!property.latitude || !property.longitude) return\n    \n    const marker = new mapboxgl.Marker()\n      .setLngLat([property.longitude, property.latitude])\n      .addTo(map.value)\n    \n    marker.getElement().addEventListener('click', () => {\n      selectedProperty.value = property\n    })\n  })\n}\n\nfunction applyFilters() {\n  fetchProperties().then(() => addPropertiesToMap())\n}\n\nfunction viewPropertyDetails(id) {\n  navigateTo(`/properties/${id}`)\n}\n\nfunction formatCurrency(value) {\n  return new Intl.NumberFormat('es-ES', {\n    style: 'currency',\n    currency: 'EUR'\n  }).format(value)\n}\n\nwatch(selectedProperty, () => {\n  if (selectedProperty.value) {\n    map.value.flyTo({\n      center: [selectedProperty.value.longitude, selectedProperty.value.latitude],\n      zoom: 15\n    })\n  }\n})\n</script>\n```",
        "testStrategy": "Verificar la correcta carga y visualización de propiedades en el mapa. Probar la funcionalidad de filtrado y búsqueda. Comprobar el rendimiento con un gran número de propiedades. Validar la interacción con los marcadores y la visualización de detalles de propiedad. Probar en diferentes dispositivos y tamaños de pantalla.",
        "priority": "high",
        "dependencies": [
          28,
          29
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 33,
        "title": "Implementar Sistema de Gestión de Leads y CRM",
        "description": "Desarrollar la funcionalidad de CRM para que los realtors puedan gestionar sus leads (clientes potenciales) y hacer seguimiento de su actividad.",
        "details": "Crear un sistema de gestión de leads con información de contacto y preferencias. Implementar seguimiento de actividad del cliente en el portal (propiedades vistas, favoritas, visitas agendadas). Desarrollar dashboard con métricas y visualizaciones para el realtor.\n\n```javascript\n// pages/dashboard/leads/index.vue\n<template>\n  <div class=\"leads-dashboard\">\n    <h1>Gestión de Leads</h1>\n    \n    <div class=\"metrics-cards\">\n      <div class=\"metric-card\">\n        <h3>Total Leads</h3>\n        <p class=\"number\">{{ metrics.totalLeads }}</p>\n      </div>\n      <div class=\"metric-card\">\n        <h3>Nuevos (30 días)</h3>\n        <p class=\"number\">{{ metrics.newLeads }}</p>\n      </div>\n      <div class=\"metric-card\">\n        <h3>Activos</h3>\n        <p class=\"number\">{{ metrics.activeLeads }}</p>\n      </div>\n      <div class=\"metric-card\">\n        <h3>Conversión</h3>\n        <p class=\"number\">{{ metrics.conversionRate }}%</p>\n      </div>\n    </div>\n    \n    <div class=\"filters\">\n      <input v-model=\"filters.search\" placeholder=\"Buscar por nombre o email...\" />\n      <select v-model=\"filters.status\">\n        <option value=\"\">Todos los estados</option>\n        <option value=\"new\">Nuevo</option>\n        <option value=\"contacted\">Contactado</option>\n        <option value=\"qualified\">Calificado</option>\n        <option value=\"negotiating\">En negociación</option>\n        <option value=\"closed\">Cerrado</option>\n      </select>\n    </div>\n    \n    <table class=\"leads-table\">\n      <thead>\n        <tr>\n          <th>Nombre</th>\n          <th>Email</th>\n          <th>Teléfono</th>\n          <th>Estado</th>\n          <th>Última Actividad</th>\n          <th>Acciones</th>\n        </tr>\n      </thead>\n      <tbody>\n        <tr v-for=\"lead in filteredLeads\" :key=\"lead.id\">\n          <td>{{ lead.first_name }} {{ lead.last_name }}</td>\n          <td>{{ lead.email }}</td>\n          <td>{{ lead.phone }}</td>\n          <td>{{ lead.status }}</td>\n          <td>{{ formatDate(lead.last_activity_date) }}</td>\n          <td class=\"actions\">\n            <button @click=\"viewLeadDetails(lead.id)\" class=\"btn-view\">Ver</button>\n            <button @click=\"editLead(lead.id)\" class=\"btn-edit\">Editar</button>\n          </td>\n        </tr>\n      </tbody>\n    </table>\n  </div>\n</template>\n\n<script setup>\nimport { ref, computed, onMounted } from 'vue'\n\nconst leads = ref([])\nconst metrics = ref({\n  totalLeads: 0,\n  newLeads: 0,\n  activeLeads: 0,\n  conversionRate: 0\n})\nconst filters = ref({\n  search: '',\n  status: ''\n})\n\nonMounted(async () => {\n  await fetchLeads()\n  await fetchMetrics()\n})\n\nasync function fetchLeads() {\n  const { data } = await useFetch('/api/leads')\n  leads.value = data.value || []\n}\n\nasync function fetchMetrics() {\n  const { data } = await useFetch('/api/leads/metrics')\n  metrics.value = data.value || {\n    totalLeads: 0,\n    newLeads: 0,\n    activeLeads: 0,\n    conversionRate: 0\n  }\n}\n\nconst filteredLeads = computed(() => {\n  return leads.value.filter(lead => {\n    const fullName = `${lead.first_name} ${lead.last_name}`.toLowerCase()\n    const matchesSearch = !filters.value.search || \n      fullName.includes(filters.value.search.toLowerCase()) ||\n      (lead.email && lead.email.toLowerCase().includes(filters.value.search.toLowerCase()))\n    \n    const matchesStatus = !filters.value.status || lead.status === filters.value.status\n    \n    return matchesSearch && matchesStatus\n  })\n})\n\nfunction viewLeadDetails(id) {\n  navigateTo(`/dashboard/leads/${id}`)\n}\n\nfunction editLead(id) {\n  navigateTo(`/dashboard/leads/${id}/edit`)\n}\n\nfunction formatDate(dateString) {\n  if (!dateString) return 'N/A'\n  return new Date(dateString).toLocaleDateString()\n}\n</script>\n```\n\n```python\n# FastAPI endpoint para actividad de leads\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom typing import List, Optional\nfrom datetime import datetime, timedelta\n\nrouter = APIRouter(prefix=\"/api/leads\", tags=[\"leads\"])\n\n@router.get(\"/activity/{lead_id}\")\nasync def get_lead_activity(\n    lead_id: int,\n    tenant_id: str = Depends(tenant_middleware),\n    current_user: User = Depends(get_current_user)\n):\n    # Verificar permisos\n    if not current_user.is_realtor:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n    \n    # Obtener actividad del lead\n    viewed_properties = await database.get_viewed_properties(tenant_id, lead_id)\n    favorite_properties = await database.get_favorite_properties(tenant_id, lead_id)\n    scheduled_showings = await database.get_scheduled_showings(tenant_id, lead_id)\n    \n    return {\n        \"viewed_properties\": viewed_properties,\n        \"favorite_properties\": favorite_properties,\n        \"scheduled_showings\": scheduled_showings\n    }\n```",
        "testStrategy": "Probar la creación, actualización y eliminación de leads. Verificar el seguimiento correcto de la actividad del cliente. Comprobar la funcionalidad de filtrado y búsqueda de leads. Validar las métricas y visualizaciones del dashboard. Probar la integración con el sistema de propiedades y visitas.",
        "priority": "high",
        "dependencies": [
          27,
          28,
          29
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 34,
        "title": "Implementar Sistema de Agendamiento de Visitas (Showings)",
        "description": "Desarrollar la funcionalidad para que los clientes puedan agendar visitas a propiedades y los realtors puedan gestionar estas solicitudes.",
        "details": "Crear un sistema de calendario para mostrar disponibilidad. Implementar formulario de solicitud de visita para clientes. Desarrollar panel de gestión de visitas para realtors con confirmación, reprogramación y cancelación. Enviar notificaciones por email para confirmaciones y recordatorios.\n\n```javascript\n// components/PropertyShowingScheduler.vue\n<template>\n  <div class=\"showing-scheduler\">\n    <h3>Agendar Visita</h3>\n    \n    <div class=\"date-picker\">\n      <h4>Seleccione una fecha:</h4>\n      <div class=\"calendar\">\n        <!-- Componente de calendario -->\n        <DatePicker v-model=\"selectedDate\" :disabled-dates=\"disabledDates\" />\n      </div>\n    </div>\n    \n    <div v-if=\"selectedDate\" class=\"time-slots\">\n      <h4>Horarios disponibles:</h4>\n      <div class=\"slots-grid\">\n        <button \n          v-for=\"slot in availableTimeSlots\" \n          :key=\"slot.time\"\n          :class=\"['time-slot', { selected: selectedTimeSlot === slot.time }]\"\n          @click=\"selectedTimeSlot = slot.time\"\n          :disabled=\"!slot.available\"\n        >\n          {{ formatTime(slot.time) }}\n        </button>\n      </div>\n    </div>\n    \n    <div v-if=\"selectedTimeSlot\" class=\"contact-form\">\n      <h4>Información de contacto:</h4>\n      <div v-if=\"!isLoggedIn\">\n        <p>Complete sus datos para agendar la visita:</p>\n        <div class=\"form-group\">\n          <label>Nombre:</label>\n          <input v-model=\"contactInfo.name\" type=\"text\" required />\n        </div>\n        <div class=\"form-group\">\n          <label>Email:</label>\n          <input v-model=\"contactInfo.email\" type=\"email\" required />\n        </div>\n        <div class=\"form-group\">\n          <label>Teléfono:</label>\n          <input v-model=\"contactInfo.phone\" type=\"tel\" required />\n        </div>\n      </div>\n      <div v-else>\n        <p>Se utilizará la información de su perfil para la visita.</p>\n      </div>\n      <div class=\"form-group\">\n        <label>Comentarios (opcional):</label>\n        <textarea v-model=\"contactInfo.comments\"></textarea>\n      </div>\n    </div>\n    \n    <button \n      @click=\"scheduleShowing\" \n      class=\"btn-schedule\" \n      :disabled=\"!canSchedule\"\n    >\n      Agendar Visita\n    </button>\n  </div>\n</template>\n\n<script setup>\nimport { ref, computed, onMounted } from 'vue'\nimport DatePicker from 'vue-datepicker-next'\nimport 'vue-datepicker-next/index.css'\n\nconst props = defineProps({\n  propertyId: {\n    type: Number,\n    required: true\n  }\n})\n\nconst selectedDate = ref(null)\nconst selectedTimeSlot = ref(null)\nconst availableTimeSlots = ref([])\nconst disabledDates = ref([])\nconst isLoggedIn = ref(false)\nconst contactInfo = ref({\n  name: '',\n  email: '',\n  phone: '',\n  comments: ''\n})\n\nonMounted(async () => {\n  // Verificar si el usuario está logueado\n  const user = useSupabaseUser()\n  isLoggedIn.value = !!user.value\n  \n  if (isLoggedIn.value) {\n    // Cargar información del usuario\n    const { data } = await useFetch('/api/user/profile')\n    if (data.value) {\n      contactInfo.value.name = `${data.value.first_name} ${data.value.last_name}`\n      contactInfo.value.email = data.value.email\n      contactInfo.value.phone = data.value.phone || ''\n    }\n  }\n  \n  // Cargar fechas no disponibles\n  await fetchDisabledDates()\n})\n\nasync function fetchDisabledDates() {\n  const { data } = await useFetch(`/api/properties/${props.propertyId}/unavailable-dates`)\n  disabledDates.value = data.value?.map(date => new Date(date)) || []\n}\n\nwatch(selectedDate, async (newDate) => {\n  if (newDate) {\n    await fetchAvailableTimeSlots(newDate)\n  } else {\n    availableTimeSlots.value = []\n    selectedTimeSlot.value = null\n  }\n})\n\nasync function fetchAvailableTimeSlots(date) {\n  const formattedDate = date.toISOString().split('T')[0]\n  const { data } = await useFetch(`/api/properties/${props.propertyId}/available-slots?date=${formattedDate}`)\n  availableTimeSlots.value = data.value || []\n}\n\nconst canSchedule = computed(() => {\n  if (!selectedDate.value || !selectedTimeSlot.value) return false\n  \n  if (!isLoggedIn.value) {\n    return !!contactInfo.value.name && !!contactInfo.value.email && !!contactInfo.value.phone\n  }\n  \n  return true\n})\n\nasync function scheduleShowing() {\n  if (!canSchedule.value) return\n  \n  const showingData = {\n    property_id: props.propertyId,\n    date: selectedDate.value.toISOString().split('T')[0],\n    time: selectedTimeSlot.value,\n    contact_info: contactInfo.value\n  }\n  \n  const { data, error } = await useFetch('/api/showings', {\n    method: 'POST',\n    body: showingData\n  })\n  \n  if (error.value) {\n    alert('Error al agendar la visita. Por favor, inténtelo de nuevo.')\n    return\n  }\n  \n  alert('¡Visita agendada con éxito! Recibirá un email de confirmación.')\n  // Resetear formulario\n  selectedDate.value = null\n  selectedTimeSlot.value = null\n  if (!isLoggedIn.value) {\n    contactInfo.value = {\n      name: '',\n      email: '',\n      phone: '',\n      comments: ''\n    }\n  } else {\n    contactInfo.value.comments = ''\n  }\n}\n\nfunction formatTime(timeString) {\n  const [hours, minutes] = timeString.split(':')\n  return `${hours}:${minutes}`\n}\n</script>\n```",
        "testStrategy": "Probar el flujo completo de agendamiento de visitas. Verificar la correcta visualización de disponibilidad y bloqueo de fechas/horas no disponibles. Comprobar la creación, confirmación, reprogramación y cancelación de visitas. Validar el envío de notificaciones por email. Probar la integración con el sistema de leads.",
        "priority": "medium",
        "dependencies": [
          28,
          29,
          33
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "Implementar Sistema de Seguimiento de Transacciones",
        "description": "Desarrollar la funcionalidad para que los realtors puedan hacer seguimiento de las transacciones inmobiliarias en diferentes etapas.",
        "details": "Crear un sistema de pipeline visual para transacciones. Implementar etapas personalizables por tipo de transacción (compra, venta, alquiler). Desarrollar funcionalidad para mover transacciones entre etapas. Integrar con el sistema de leads y propiedades.\n\n```javascript\n// pages/dashboard/transactions/index.vue\n<template>\n  <div class=\"transactions-dashboard\">\n    <h1>Pipeline de Transacciones</h1>\n    \n    <div class=\"transaction-type-selector\">\n      <button \n        v-for=\"type in transactionTypes\" \n        :key=\"type.value\"\n        :class=\"['type-btn', { active: selectedType === type.value }]\"\n        @click=\"selectedType = type.value\"\n      >\n        {{ type.label }}\n      </button>\n    </div>\n    \n    <div class=\"pipeline-container\">\n      <div \n        v-for=\"stage in stagesForSelectedType\" \n        :key=\"stage.id\"\n        class=\"pipeline-stage\"\n      >\n        <div class=\"stage-header\">\n          <h3>{{ stage.name }}</h3>\n          <span class=\"count\">{{ transactionsInStage(stage.id).length }}</span>\n        </div>\n        \n        <div class=\"stage-body\">\n          <div \n            v-for=\"transaction in transactionsInStage(stage.id)\" \n            :key=\"transaction.id\"\n            class=\"transaction-card\"\n            draggable=\"true\"\n            @dragstart=\"dragStart(transaction, $event)\"\n          >\n            <div class=\"card-header\">\n              <h4>{{ transaction.property.title }}</h4>\n              <span class=\"price\">{{ formatCurrency(transaction.property.price) }}</span>\n            </div>\n            <div class=\"card-body\">\n              <p class=\"client\">Cliente: {{ transaction.lead.first_name }} {{ transaction.lead.last_name }}</p>\n              <p class=\"date\">Actualizado: {{ formatDate(transaction.updated_at) }}</p>\n            </div>\n            <div class=\"card-actions\">\n              <button @click=\"viewTransactionDetails(transaction.id)\" class=\"btn-view\">\n                Ver Detalles\n              </button>\n            </div>\n          </div>\n          \n          <div \n            class=\"drop-zone\" \n            @dragover.prevent\n            @drop=\"dropTransaction($event, stage.id)\"\n          ></div>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport { ref, computed, onMounted } from 'vue'\n\nconst transactions = ref([])\nconst stages = ref([])\nconst selectedType = ref('purchase') // Valor por defecto\nconst draggedTransaction = ref(null)\n\nconst transactionTypes = [\n  { value: 'purchase', label: 'Compra' },\n  { value: 'sale', label: 'Venta' },\n  { value: 'rental', label: 'Alquiler' },\n  { value: 'temp_rental', label: 'Alquiler Temporario' }\n]\n\nonMounted(async () => {\n  await Promise.all([\n    fetchTransactions(),\n    fetchStages()\n  ])\n})\n\nasync function fetchTransactions() {\n  const { data } = await useFetch(`/api/transactions?type=${selectedType.value}`)\n  transactions.value = data.value || []\n}\n\nasync function fetchStages() {\n  const { data } = await useFetch('/api/transaction-stages')\n  stages.value = data.value || []\n}\n\nconst stagesForSelectedType = computed(() => {\n  return stages.value.filter(stage => stage.transaction_type === selectedType.value)\n})\n\nfunction transactionsInStage(stageId) {\n  return transactions.value.filter(transaction => transaction.stage_id === stageId)\n}\n\nfunction dragStart(transaction, event) {\n  draggedTransaction.value = transaction\n  event.dataTransfer.effectAllowed = 'move'\n}\n\nasync function dropTransaction(event, stageId) {\n  if (!draggedTransaction.value) return\n  \n  const transactionId = draggedTransaction.value.id\n  \n  // Actualizar en la UI primero para una experiencia más fluida\n  const transactionIndex = transactions.value.findIndex(t => t.id === transactionId)\n  if (transactionIndex !== -1) {\n    transactions.value[transactionIndex].stage_id = stageId\n    transactions.value[transactionIndex].updated_at = new Date().toISOString()\n  }\n  \n  // Luego actualizar en el servidor\n  await useFetch(`/api/transactions/${transactionId}/stage`, {\n    method: 'PUT',\n    body: { stage_id: stageId }\n  })\n  \n  draggedTransaction.value = null\n}\n\nfunction viewTransactionDetails(id) {\n  navigateTo(`/dashboard/transactions/${id}`)\n}\n\nfunction formatCurrency(value) {\n  return new Intl.NumberFormat('es-ES', {\n    style: 'currency',\n    currency: 'EUR'\n  }).format(value)\n}\n\nfunction formatDate(dateString) {\n  return new Date(dateString).toLocaleDateString()\n}\n\nwatch(selectedType, async () => {\n  await fetchTransactions()\n})\n</script>\n```\n\n```python\n# Esquema de base de datos para transacciones\n'''\nCREATE TABLE tenant_{tenant_id}.transaction_stages (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    transaction_type VARCHAR(50) NOT NULL,\n    position INT NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE tenant_{tenant_id}.transactions (\n    id SERIAL PRIMARY KEY,\n    lead_id INT REFERENCES tenant_{tenant_id}.leads(id),\n    property_id INT REFERENCES tenant_{tenant_id}.properties(id),\n    transaction_type VARCHAR(50) NOT NULL,\n    stage_id INT REFERENCES tenant_{tenant_id}.transaction_stages(id),\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n'''\n```",
        "testStrategy": "Probar la creación y gestión de transacciones. Verificar la funcionalidad de arrastrar y soltar para mover transacciones entre etapas. Comprobar la personalización de etapas por tipo de transacción. Validar la integración con el sistema de leads y propiedades. Probar la visualización del pipeline en diferentes dispositivos.",
        "priority": "medium",
        "dependencies": [
          27,
          28,
          33
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 36,
        "title": "Implementar Sistema de Favoritos y Alertas de Precio",
        "description": "Desarrollar la funcionalidad para que los clientes puedan guardar propiedades como favoritas y recibir alertas de cambios de precio.",
        "details": "Crear sistema de favoritos para usuarios registrados. Implementar funcionalidad para guardar/eliminar favoritos. Desarrollar sistema de alertas de precio que notifique a los usuarios cuando una propiedad favorita cambie de precio. Integrar con n8n para la automatización de alertas.\n\n```javascript\n// components/PropertyFavoriteButton.vue\n<template>\n  <button \n    @click=\"toggleFavorite\" \n    :class=\"['favorite-btn', { active: isFavorite }]\"\n    :disabled=\"isLoading\"\n  >\n    <span v-if=\"isFavorite\" class=\"icon\">❤️</span>\n    <span v-else class=\"icon\">🤍</span>\n    <span class=\"text\">{{ isFavorite ? 'Guardado' : 'Guardar' }}</span>\n  </button>\n</template>\n\n<script setup>\nimport { ref, onMounted } from 'vue'\n\nconst props = defineProps({\n  propertyId: {\n    type: Number,\n    required: true\n  }\n})\n\nconst isFavorite = ref(false)\nconst isLoading = ref(false)\nconst isLoggedIn = ref(false)\n\nonMounted(async () => {\n  const user = useSupabaseUser()\n  isLoggedIn.value = !!user.value\n  \n  if (isLoggedIn.value) {\n    await checkFavoriteStatus()\n  }\n})\n\nasync function checkFavoriteStatus() {\n  isLoading.value = true\n  const { data } = await useFetch(`/api/favorites/check/${props.propertyId}`)\n  isFavorite.value = data.value?.is_favorite || false\n  isLoading.value = false\n}\n\nasync function toggleFavorite() {\n  if (!isLoggedIn.value) {\n    // Redirigir a login si no está autenticado\n    const currentPath = window.location.pathname\n    navigateTo(`/login?redirect=${encodeURIComponent(currentPath)}`)\n    return\n  }\n  \n  isLoading.value = true\n  \n  if (isFavorite.value) {\n    // Eliminar de favoritos\n    await useFetch(`/api/favorites/${props.propertyId}`, {\n      method: 'DELETE'\n    })\n    isFavorite.value = false\n  } else {\n    // Añadir a favoritos\n    await useFetch('/api/favorites', {\n      method: 'POST',\n      body: { property_id: props.propertyId }\n    })\n    isFavorite.value = true\n  }\n  \n  isLoading.value = false\n}\n</script>\n```\n\n```python\n# FastAPI endpoints para favoritos y alertas\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom typing import List\n\nrouter = APIRouter(prefix=\"/api/favorites\", tags=[\"favorites\"])\n\n@router.post(\"/\")\nasync def add_favorite(\n    favorite: FavoriteCreate,\n    tenant_id: str = Depends(tenant_middleware),\n    current_user: User = Depends(get_current_user)\n):\n    if not current_user:\n        raise HTTPException(status_code=401, detail=\"Not authenticated\")\n    \n    # Añadir a favoritos\n    await database.add_favorite(tenant_id, current_user.id, favorite.property_id)\n    \n    # Configurar alerta de precio si está habilitada\n    if favorite.enable_price_alert:\n        await setup_price_alert(tenant_id, current_user.id, favorite.property_id)\n    \n    return {\"status\": \"success\"}\n\n@router.delete(\"/{property_id}\")\nasync def remove_favorite(\n    property_id: int,\n    tenant_id: str = Depends(tenant_middleware),\n    current_user: User = Depends(get_current_user)\n):\n    if not current_user:\n        raise HTTPException(status_code=401, detail=\"Not authenticated\")\n    \n    # Eliminar de favoritos\n    await database.remove_favorite(tenant_id, current_user.id, property_id)\n    \n    # Eliminar alerta de precio si existe\n    await remove_price_alert(tenant_id, current_user.id, property_id)\n    \n    return {\"status\": \"success\"}\n\nasync def setup_price_alert(tenant_id: str, user_id: str, property_id: int):\n    # Obtener información actual de la propiedad\n    property_info = await database.get_property(tenant_id, property_id)\n    \n    # Registrar en la tabla de alertas\n    await database.create_price_alert(tenant_id, user_id, property_id, property_info.price)\n    \n    # Configurar workflow en n8n\n    # Esto podría ser una llamada a la API de n8n o un registro en una tabla que n8n monitorea\n    pass\n```\n\n```sql\n-- Esquema para favoritos y alertas de precio\nCREATE TABLE tenant_{tenant_id}.favorites (\n    id SERIAL PRIMARY KEY,\n    user_id UUID REFERENCES auth.users(id),\n    property_id INT REFERENCES tenant_{tenant_id}.properties(id),\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    UNIQUE(user_id, property_id)\n);\n\nCREATE TABLE tenant_{tenant_id}.price_alerts (\n    id SERIAL PRIMARY KEY,\n    user_id UUID REFERENCES auth.users(id),\n    property_id INT REFERENCES tenant_{tenant_id}.properties(id),\n    original_price DECIMAL(12,2) NOT NULL,\n    last_checked_price DECIMAL(12,2) NOT NULL,\n    is_active BOOLEAN DEFAULT TRUE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    UNIQUE(user_id, property_id)\n);\n```",
        "testStrategy": "Probar la funcionalidad de añadir y eliminar favoritos. Verificar que los usuarios no autenticados sean redirigidos al login. Comprobar que las alertas de precio se configuren correctamente. Probar el envío de notificaciones cuando cambie el precio de una propiedad favorita. Validar la integración con n8n para la automatización de alertas.",
        "priority": "medium",
        "dependencies": [
          28,
          29,
          32
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 37,
        "title": "Implementar Carga Masiva de Propiedades",
        "description": "Desarrollar la funcionalidad para que los realtors puedan importar múltiples propiedades mediante archivos CSV o integración con APIs externas.",
        "details": "Crear interfaz para carga de archivos CSV. Implementar validación y mapeo de campos. Desarrollar proceso de importación en segundo plano. Proporcionar feedback sobre el progreso y resultados de la importación. Implementar integración con APIs externas de propiedades.\n\n```javascript\n// pages/dashboard/properties/import.vue\n<template>\n  <div class=\"property-import\">\n    <h1>Importación de Propiedades</h1>\n    \n    <div class=\"import-options\">\n      <div class=\"option-card\">\n        <h3>Importar desde CSV</h3>\n        <p>Sube un archivo CSV con tus propiedades.</p>\n        <div class=\"file-upload\">\n          <input \n            type=\"file\" \n            ref=\"fileInput\"\n            accept=\".csv\"\n            @change=\"handleFileUpload\"\n          />\n          <button @click=\"triggerFileInput\" class=\"btn-upload\">\n            Seleccionar Archivo\n          </button>\n          <span v-if=\"selectedFile\">{{ selectedFile.name }}</span>\n        </div>\n        <div v-if=\"selectedFile\" class=\"field-mapping\">\n          <h4>Mapeo de Campos</h4>\n          <p>Asigna las columnas de tu CSV a los campos de propiedades:</p>\n          \n          <div v-for=\"field in requiredFields\" :key=\"field.key\" class=\"field-map\">\n            <label>{{ field.label }}:</label>\n            <select v-model=\"fieldMapping[field.key]\">\n              <option value=\"\">-- Seleccionar columna --</option>\n              <option v-for=\"column in csvColumns\" :key=\"column\" :value=\"column\">\n                {{ column }}\n              </option>\n            </select>\n          </div>\n          \n          <button @click=\"startImport\" class=\"btn-start-import\" :disabled=\"!canStartImport\">\n            Iniciar Importación\n          </button>\n        </div>\n      </div>\n      \n      <div class=\"option-card\">\n        <h3>Importar desde API Externa</h3>\n        <p>Conecta con una API externa para importar propiedades.</p>\n        <div class=\"api-selection\">\n          <select v-model=\"selectedApi\">\n            <option value=\"\">-- Seleccionar API --</option>\n            <option v-for=\"api in availableApis\" :key=\"api.id\" :value=\"api.id\">\n              {{ api.name }}\n            </option>\n          </select>\n        </div>\n        <div v-if=\"selectedApi\" class=\"api-config\">\n          <h4>Configuración de API</h4>\n          <!-- Campos específicos según la API seleccionada -->\n          <div v-if=\"selectedApi === 'idealista'\" class=\"api-fields\">\n            <div class=\"field\">\n              <label>API Key:</label>\n              <input type=\"password\" v-model=\"apiConfig.apiKey\" />\n            </div>\n            <div class=\"field\">\n              <label>Secret:</label>\n              <input type=\"password\" v-model=\"apiConfig.secret\" />\n            </div>\n          </div>\n          \n          <button @click=\"startApiImport\" class=\"btn-start-import\" :disabled=\"!canStartApiImport\">\n            Iniciar Importación desde API\n          </button>\n        </div>\n      </div>\n    </div>\n    \n    <div v-if=\"importStatus\" class=\"import-status\">\n      <h3>Estado de la Importación</h3>\n      <div class=\"progress-bar\">\n        <div \n          class=\"progress\" \n          :style=\"{ width: `${importStatus.progress}%` }\"\n        ></div>\n      </div>\n      <p class=\"status-text\">{{ importStatus.message }}</p>\n      <div v-if=\"importStatus.completed\" class=\"import-results\">\n        <p>Total procesadas: {{ importStatus.total }}</p>\n        <p>Importadas correctamente: {{ importStatus.success }}</p>\n        <p>Con errores: {{ importStatus.errors }}</p>\n        <button v-if=\"importStatus.errors > 0\" @click=\"downloadErrorLog\" class=\"btn-download\">\n          Descargar Log de Errores\n        </button>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport { ref, computed, onMounted } from 'vue'\nimport Papa from 'papaparse'\n\nconst fileInput = ref(null)\nconst selectedFile = ref(null)\nconst csvColumns = ref([])\nconst fieldMapping = ref({})\nconst importStatus = ref(null)\nconst selectedApi = ref('')\nconst apiConfig = ref({\n  apiKey: '',\n  secret: ''\n})\n\nconst requiredFields = [\n  { key: 'title', label: 'Título' },\n  { key: 'description', label: 'Descripción' },\n  { key: 'property_type', label: 'Tipo de Propiedad' },\n  { key: 'price', label: 'Precio' },\n  { key: 'address', label: 'Dirección' },\n  { key: 'city', label: 'Ciudad' },\n  { key: 'bedrooms', label: 'Habitaciones' },\n  { key: 'bathrooms', label: 'Baños' },\n  { key: 'area', label: 'Superficie (m²)' },\n  { key: 'status', label: 'Estado' }\n]\n\nconst availableApis = [\n  { id: 'idealista', name: 'Idealista' },\n  { id: 'fotocasa', name: 'Fotocasa' },\n  { id: 'habitaclia', name: 'Habitaclia' }\n]\n\nfunction triggerFileInput() {\n  fileInput.value.click()\n}\n\nfunction handleFileUpload(event) {\n  const file = event.target.files[0]\n  if (!file) return\n  \n  selectedFile.value = file\n  \n  // Parsear las primeras filas para obtener las columnas\n  Papa.parse(file, {\n    preview: 1,\n    header: true,\n    complete: function(results) {\n      csvColumns.value = Object.keys(results.data[0])\n      \n      // Intentar mapeo automático por nombres similares\n      requiredFields.forEach(field => {\n        const matchingColumn = csvColumns.value.find(column => \n          column.toLowerCase().includes(field.key.toLowerCase())\n        )\n        if (matchingColumn) {\n          fieldMapping.value[field.key] = matchingColumn\n        }\n      })\n    }\n  })\n}\n\nconst canStartImport = computed(() => {\n  if (!selectedFile.value) return false\n  \n  // Verificar que todos los campos requeridos estén mapeados\n  return requiredFields.every(field => !!fieldMapping.value[field.key])\n})\n\nconst canStartApiImport = computed(() => {\n  if (!selectedApi.value) return false\n  \n  if (selectedApi.value === 'idealista') {\n    return !!apiConfig.value.apiKey && !!apiConfig.value.secret\n  }\n  \n  return true\n})\n\nasync function startImport() {\n  if (!canStartImport.value) return\n  \n  // Iniciar estado de importación\n  importStatus.value = {\n    progress: 0,\n    message: 'Iniciando importación...',\n    completed: false,\n    total: 0,\n    success: 0,\n    errors: 0\n  }\n  \n  // Crear FormData para enviar el archivo y el mapeo\n  const formData = new FormData()\n  formData.append('file', selectedFile.value)\n  formData.append('mapping', JSON.stringify(fieldMapping.value))\n  \n  // Iniciar la importación\n  const response = await fetch('/api/properties/import/csv', {\n    method: 'POST',\n    body: formData\n  })\n  \n  const { job_id } = await response.json()\n  \n  // Iniciar polling para seguimiento del progreso\n  pollImportStatus(job_id)\n}\n\nasync function startApiImport() {\n  if (!canStartApiImport.value) return\n  \n  // Iniciar estado de importación\n  importStatus.value = {\n    progress: 0,\n    message: 'Iniciando importación desde API...',\n    completed: false,\n    total: 0,\n    success: 0,\n    errors: 0\n  }\n  \n  // Enviar configuración de API\n  const response = await fetch(`/api/properties/import/api/${selectedApi.value}`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(apiConfig.value)\n  })\n  \n  const { job_id } = await response.json()\n  \n  // Iniciar polling para seguimiento del progreso\n  pollImportStatus(job_id)\n}\n\nasync function pollImportStatus(jobId) {\n  const intervalId = setInterval(async () => {\n    const response = await fetch(`/api/import-jobs/${jobId}`)\n    const status = await response.json()\n    \n    importStatus.value = status\n    \n    if (status.completed) {\n      clearInterval(intervalId)\n    }\n  }, 2000)\n}\n\nasync function downloadErrorLog() {\n  if (!importStatus.value || !importStatus.value.job_id) return\n  \n  const response = await fetch(`/api/import-jobs/${importStatus.value.job_id}/errors`)\n  const blob = await response.blob()\n  \n  const url = window.URL.createObjectURL(blob)\n  const a = document.createElement('a')\n  a.href = url\n  a.download = `import-errors-${new Date().toISOString().split('T')[0]}.csv`\n  document.body.appendChild(a)\n  a.click()\n  a.remove()\n}\n</script>\n```\n\n```python\n# FastAPI endpoints para importación de propiedades\nfrom fastapi import APIRouter, UploadFile, File, Form, BackgroundTasks\nfrom typing import Dict, Any\nimport json\nimport csv\nimport io\n\nrouter = APIRouter(prefix=\"/api/properties\", tags=[\"properties\"])\n\n@router.post(\"/import/csv\")\nasync def import_properties_csv(\n    background_tasks: BackgroundTasks,\n    file: UploadFile = File(...),\n    mapping: str = Form(...),\n    tenant_id: str = Depends(tenant_middleware),\n    current_user: User = Depends(get_current_user)\n):\n    if not current_user.is_realtor:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n    \n    # Parsear el mapeo de campos\n    field_mapping = json.loads(mapping)\n    \n    # Crear un job de importación\n    job_id = await database.create_import_job(tenant_id, current_user.id, 'csv')\n    \n    # Iniciar tarea en segundo plano\n    background_tasks.add_task(\n        process_csv_import, \n        tenant_id, \n        job_id, \n        await file.read(), \n        field_mapping\n    )\n    \n    return {\"job_id\": job_id}\n\nasync def process_csv_import(tenant_id: str, job_id: int, file_content: bytes, field_mapping: Dict[str, str]):\n    # Actualizar estado del job\n    await database.update_import_job(tenant_id, job_id, {\n        \"status\": \"processing\",\n        \"progress\": 0,\n        \"message\": \"Procesando archivo CSV...\"\n    })\n    \n    # Procesar el CSV\n    csv_file = io.StringIO(file_content.decode('utf-8'))\n    reader = csv.DictReader(csv_file)\n    rows = list(reader)\n    total_rows = len(rows)\n    \n    success_count = 0\n    error_count = 0\n    errors = []\n    \n    for i, row in enumerate(rows):\n        try:\n            # Mapear campos según la configuración\n            property_data = {}\n            for field_key, csv_column in field_mapping.items():\n                property_data[field_key] = row[csv_column]\n            \n            # Validar y convertir tipos de datos\n            if 'price' in property_data:\n                property_data['price'] = float(property_data['price'].replace(',', '.'))\n            if 'bedrooms' in property_data:\n                property_data['bedrooms'] = int(property_data['bedrooms'])\n            if 'bathrooms' in property_data:\n                property_data['bathrooms'] = float(property_data['bathrooms'].replace(',', '.'))\n            if 'area' in property_data:\n                property_data['area'] = float(property_data['area'].replace(',', '.'))\n            \n            # Crear la propiedad\n            await database.create_property(tenant_id, property_data)\n            success_count += 1\n        except Exception as e:\n            error_count += 1\n            errors.append({\n                \"row\": i + 1,\n                \"data\": row,\n                \"error\": str(e)\n            })\n        \n        # Actualizar progreso\n        progress = int((i + 1) / total_rows * 100)\n        await database.update_import_job(tenant_id, job_id, {\n            \"progress\": progress,\n            \"message\": f\"Procesando {i + 1} de {total_rows}...\"\n        })\n    \n    # Actualizar estado final\n    await database.update_import_job(tenant_id, job_id, {\n        \"status\": \"completed\",\n        \"progress\": 100,\n        \"message\": \"Importación completada\",\n        \"completed\": True,\n        \"total\": total_rows,\n        \"success\": success_count,\n        \"errors\": error_count,\n        \"error_details\": errors\n    })\n```",
        "testStrategy": "Probar la carga y procesamiento de archivos CSV con diferentes formatos. Verificar el mapeo correcto de campos. Comprobar el manejo de errores durante la importación. Validar el seguimiento del progreso en tiempo real. Probar la integración con APIs externas para importación de propiedades.",
        "priority": "medium",
        "dependencies": [
          28,
          31
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 38,
        "title": "Implementar Búsqueda Semántica con Base de Datos Vectorial",
        "description": "Desarrollar un sistema de búsqueda avanzada utilizando Qdrant como base de datos vectorial para búsquedas semánticas de propiedades.",
        "details": "Integrar Qdrant para almacenar embeddings de propiedades. Implementar generación de embeddings a partir de descripciones y características de propiedades. Desarrollar API de búsqueda semántica que permita encontrar propiedades similares o basadas en consultas en lenguaje natural.\n\n```python\n# Integración con Qdrant para búsqueda semántica\nfrom fastapi import APIRouter, Depends, Query\nfrom typing import List, Optional\nimport numpy as np\nfrom qdrant_client import QdrantClient\nfrom qdrant_client.http.models import Distance, VectorParams, PointStruct\nfrom sentence_transformers import SentenceTransformer\n\nrouter = APIRouter(prefix=\"/api/search\", tags=[\"search\"])\n\n# Inicializar el modelo de embeddings y cliente Qdrant\nmodel = SentenceTransformer('paraphrase-multilingual-MiniLM-L12-v2')\nqdrant_client = QdrantClient(host=\"qdrant\", port=6333)\n\n# Asegurar que la colección existe\ndef ensure_collection(tenant_id: str):\n    collection_name = f\"properties_{tenant_id}\"\n    collections = qdrant_client.get_collections().collections\n    collection_names = [c.name for c in collections]\n    \n    if collection_name not in collection_names:\n        qdrant_client.create_collection(\n            collection_name=collection_name,\n            vectors_config=VectorParams(size=384, distance=Distance.COSINE)\n        )\n    \n    return collection_name\n\n# Generar embedding para una propiedad\ndef generate_property_embedding(property_data):\n    # Crear texto que represente la propiedad\n    text = f\"{property_data['title']}. {property_data['description']}. \"\n    text += f\"Tipo: {property_data['property_type']}. \"\n    text += f\"Ubicación: {property_data['city']}, {property_data.get('state', '')}. \"\n    text += f\"{property_data.get('bedrooms', 0)} habitaciones, {property_data.get('bathrooms', 0)} baños. \"\n    text += f\"{property_data.get('area', 0)} m².\"\n    \n    # Generar embedding\n    embedding = model.encode(text)\n    return embedding\n\n# Endpoint para indexar una propiedad\n@router.post(\"/index-property/{property_id}\")\nasync def index_property(\n    property_id: int,\n    tenant_id: str = Depends(tenant_middleware),\n    current_user: User = Depends(get_current_user)\n):\n    if not current_user.is_realtor:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n    \n    # Obtener datos de la propiedad\n    property_data = await database.get_property(tenant_id, property_id)\n    if not property_data:\n        raise HTTPException(status_code=404, detail=\"Property not found\")\n    \n    # Generar embedding\n    embedding = generate_property_embedding(property_data)\n    \n    # Asegurar que la colección existe\n    collection_name = ensure_collection(tenant_id)\n    \n    # Indexar la propiedad\n    qdrant_client.upsert(\n        collection_name=collection_name,\n        points=[\n            PointStruct(\n                id=property_id,\n                vector=embedding.tolist(),\n                payload={\n                    \"property_id\": property_id,\n                    \"title\": property_data[\"title\"],\n                    \"price\": float(property_data[\"price\"]),\n                    \"property_type\": property_data[\"property_type\"],\n                    \"bedrooms\": property_data.get(\"bedrooms\"),\n                    \"bathrooms\": property_data.get(\"bathrooms\"),\n                    \"area\": property_data.get(\"area\")\n                }\n            )\n        ]\n    )\n    \n    return {\"status\": \"indexed\"}\n\n# Endpoint para búsqueda semántica\n@router.get(\"/semantic\")\nasync def semantic_search(\n    query: str,\n    limit: int = Query(10, ge=1, le=100),\n    tenant_id: str = Depends(tenant_middleware)\n):\n    # Generar embedding de la consulta\n    query_embedding = model.encode(query)\n    \n    # Asegurar que la colección existe\n    collection_name = ensure_collection(tenant_id)\n    \n    # Realizar búsqueda\n    search_result = qdrant_client.search(\n        collection_name=collection_name,\n        query_vector=query_embedding.tolist(),\n        limit=limit\n    )\n    \n    # Obtener IDs de propiedades encontradas\n    property_ids = [hit.id for hit in search_result]\n    \n    # Obtener datos completos de las propiedades\n    properties = await database.get_properties_by_ids(tenant_id, property_ids)\n    \n    # Ordenar propiedades según el orden de los resultados de búsqueda\n    property_dict = {prop[\"id\"]: prop for prop in properties}\n    ordered_properties = [property_dict[pid] for pid in property_ids if pid in property_dict]\n    \n    return ordered_properties\n\n# Endpoint para propiedades similares\n@router.get(\"/similar/{property_id}\")\nasync def similar_properties(\n    property_id: int,\n    limit: int = Query(5, ge=1, le=20),\n    tenant_id: str = Depends(tenant_middleware)\n):\n    # Obtener datos de la propiedad\n    property_data = await database.get_property(tenant_id, property_id)\n    if not property_data:\n        raise HTTPException(status_code=404, detail=\"Property not found\")\n    \n    # Generar embedding\n    embedding = generate_property_embedding(property_data)\n    \n    # Asegurar que la colección existe\n    collection_name = ensure_collection(tenant_id)\n    \n    # Realizar búsqueda de similares\n    search_result = qdrant_client.search(\n        collection_name=collection_name,\n        query_vector=embedding.tolist(),\n        limit=limit + 1  # +1 porque la propiedad misma será el primer resultado\n    )\n    \n    # Filtrar la propiedad original y obtener IDs\n    property_ids = [hit.id for hit in search_result if hit.id != property_id]\n    \n    # Obtener datos completos de las propiedades\n    properties = await database.get_properties_by_ids(tenant_id, property_ids)\n    \n    return properties\n```\n\n```javascript\n// components/SemanticSearchBar.vue\n<template>\n  <div class=\"semantic-search\">\n    <div class=\"search-input\">\n      <input \n        v-model=\"searchQuery\" \n        type=\"text\" \n        placeholder=\"Describe la propiedad que buscas...\"\n        @keyup.enter=\"performSearch\"\n      />\n      <button @click=\"performSearch\" class=\"btn-search\">\n        <span class=\"icon\">🔍</span>\n      </button>\n    </div>\n    \n    <div v-if=\"isSearching\" class=\"loading\">\n      Buscando...\n    </div>\n    \n    <div v-if=\"searchResults.length > 0\" class=\"search-results\">\n      <h3>Resultados de búsqueda</h3>\n      <div class=\"results-grid\">\n        <PropertyCard \n          v-for=\"property in searchResults\" \n          :key=\"property.id\"\n          :property=\"property\"\n        />\n      </div>\n    </div>\n    \n    <div v-if=\"searchPerformed && searchResults.length === 0\" class=\"no-results\">\n      No se encontraron propiedades que coincidan con tu búsqueda.\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\nimport PropertyCard from '~/components/PropertyCard.vue'\n\nconst searchQuery = ref('')\nconst searchResults = ref([])\nconst isSearching = ref(false)\nconst searchPerformed = ref(false)\n\nasync function performSearch() {\n  if (!searchQuery.value.trim()) return\n  \n  isSearching.value = true\n  searchPerformed.value = true\n  \n  try {\n    const { data } = await useFetch(`/api/search/semantic?query=${encodeURIComponent(searchQuery.value)}`)\n    searchResults.value = data.value || []\n  } catch (error) {\n    console.error('Error en búsqueda semántica:', error)\n    searchResults.value = []\n  } finally {\n    isSearching.value = false\n  }\n}\n</script>\n```",
        "testStrategy": "Probar la generación de embeddings para diferentes tipos de propiedades. Verificar la indexación correcta en Qdrant. Comprobar la búsqueda semántica con diferentes consultas en lenguaje natural. Validar la búsqueda de propiedades similares. Probar el rendimiento con un gran número de propiedades indexadas.",
        "priority": "medium",
        "dependencies": [
          28,
          31,
          32
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 39,
        "title": "Configurar Despliegue con Docker Swarm y Portainer",
        "description": "Implementar la infraestructura de despliegue utilizando Docker Swarm para orquestación de contenedores y Portainer para gestión.",
        "details": "Crear archivos Docker Compose para definir servicios. Configurar Docker Swarm para alta disponibilidad. Implementar Portainer para gestión visual de contenedores. Configurar redes y volúmenes persistentes. Implementar estrategias de despliegue continuo.\n\n```yaml\n# docker-compose.yml\nversion: '3.8'\n\nservices:\n  # Frontend (Nuxt.js)\n  frontend:\n    build:\n      context: ./frontend\n      dockerfile: Dockerfile\n    image: ${REGISTRY}/plataforma-inmobiliaria-frontend:${TAG:-latest}\n    deploy:\n      replicas: 2\n      update_config:\n        parallelism: 1\n        delay: 10s\n        order: start-first\n      restart_policy:\n        condition: on-failure\n    networks:\n      - frontend-network\n    depends_on:\n      - api\n\n  # API Backend (FastAPI)\n  api:\n    build:\n      context: ./backend\n      dockerfile: Dockerfile\n    image: ${REGISTRY}/plataforma-inmobiliaria-api:${TAG:-latest}\n    deploy:\n      replicas: 2\n      update_config:\n        parallelism: 1\n        delay: 10s\n        order: start-first\n      restart_policy:\n        condition: on-failure\n    environment:\n      - DATABASE_URL=postgresql://postgres:${POSTGRES_PASSWORD}@postgres:5432/plataforma_inmobiliaria\n      - SUPABASE_URL=${SUPABASE_URL}\n      - SUPABASE_KEY=${SUPABASE_KEY}\n      - QDRANT_HOST=qdrant\n      - QDRANT_PORT=6333\n    networks:\n      - backend-network\n      - frontend-network\n    depends_on:\n      - postgres\n      - qdrant\n\n  # PostgreSQL\n  postgres:\n    image: postgres:14-alpine\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n    environment:\n      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}\n      - POSTGRES_DB=plataforma_inmobiliaria\n    deploy:\n      placement:\n        constraints:\n          - node.role == manager\n      restart_policy:\n        condition: on-failure\n    networks:\n      - backend-network\n\n  # Qdrant (Vector Database)\n  qdrant:\n    image: qdrant/qdrant:latest\n    volumes:\n      - qdrant-data:/qdrant/storage\n    deploy:\n      placement:\n        constraints:\n          - node.role == manager\n      restart_policy:\n        condition: on-failure\n    networks:\n      - backend-network\n\n  # n8n (Workflow Automation)\n  n8n:\n    image: n8nio/n8n:latest\n    environment:\n      - N8N_BASIC_AUTH_ACTIVE=true\n      - N8N_BASIC_AUTH_USER=${N8N_USER}\n      - N8N_BASIC_AUTH_PASSWORD=${N8N_PASSWORD}\n      - N8N_HOST=${N8N_HOST}\n      - N8N_PORT=5678\n      - N8N_PROTOCOL=https\n      - NODE_ENV=production\n      - WEBHOOK_URL=https://${N8N_HOST}\n    volumes:\n      - n8n-data:/home/node/.n8n\n    deploy:\n      placement:\n        constraints:\n          - node.role == manager\n      restart_policy:\n        condition: on-failure\n    networks:\n      - backend-network\n      - frontend-network\n\n  # Nginx (Reverse Proxy)\n  nginx:\n    image: nginx:alpine\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - ./nginx/conf.d:/etc/nginx/conf.d\n      - ./nginx/ssl:/etc/nginx/ssl\n      - ./nginx/www:/var/www/html\n    deploy:\n      replicas: 2\n      update_config:\n        parallelism: 1\n        delay: 10s\n      restart_policy:\n        condition: on-failure\n    networks:\n      - frontend-network\n\n  # Portainer (Container Management)\n  portainer:\n    image: portainer/portainer-ce:latest\n    command: -H unix:///var/run/docker.sock\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n      - portainer-data:/data\n    ports:\n      - \"9000:9000\"\n    deploy:\n      placement:\n        constraints:\n          - node.role == manager\n      restart_policy:\n        condition: on-failure\n    networks:\n      - frontend-network\n\nnetworks:\n  frontend-network:\n    driver: overlay\n  backend-network:\n    driver: overlay\n\nvolumes:\n  postgres-data:\n  qdrant-data:\n  n8n-data:\n  portainer-data:\n```\n\n```bash\n#!/bin/bash\n# deploy.sh - Script para desplegar la aplicación en Docker Swarm\n\n# Cargar variables de entorno\nset -a\nsource .env\nset +a\n\n# Inicializar Docker Swarm si no está inicializado\nif ! docker info | grep -q \"Swarm: active\"; then\n  echo \"Inicializando Docker Swarm...\"\n  docker swarm init --advertise-addr $(hostname -I | awk '{print $1}')\nfi\n\n# Crear redes si no existen\nif ! docker network ls | grep -q \"frontend-network\"; then\n  echo \"Creando red frontend-network...\"\n  docker network create --driver overlay frontend-network\nfi\n\nif ! docker network ls | grep -q \"backend-network\"; then\n  echo \"Creando red backend-network...\"\n  docker network create --driver overlay backend-network\nfi\n\n# Desplegar stack\necho \"Desplegando stack de aplicación...\"\ndocker stack deploy -c docker-compose.yml plataforma-inmobiliaria\n\necho \"Despliegue completado. Accede a Portainer en http://$(hostname -I | awk '{print $1}'):9000\"\n```",
        "testStrategy": "Probar el despliegue en entornos de desarrollo, staging y producción. Verificar la correcta configuración de redes y volúmenes. Comprobar la alta disponibilidad y balanceo de carga. Validar la gestión de contenedores a través de Portainer. Probar estrategias de actualización y rollback.",
        "priority": "high",
        "dependencies": [
          28,
          29
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 40,
        "title": "Desplegar Frontend de Nuxt.js a Vercel",
        "description": "Configurar y desplegar la aplicación frontend de Nuxt.js a un entorno de producción/staging utilizando la plataforma Vercel para garantizar un despliegue continuo y eficiente.",
        "details": "1. Crear una cuenta en Vercel si aún no se tiene una.\n\n2. Instalar la CLI de Vercel para facilitar el despliegue:\n```bash\nnpm install -g vercel\n```\n\n3. Configurar el proyecto Nuxt.js para producción:\n   - Asegurar que el archivo `nuxt.config.js` esté correctamente configurado para producción\n   - Verificar las variables de entorno necesarias\n\n```javascript\n// nuxt.config.js\nexport default defineNuxtConfig({\n  // Configuración para producción\n  app: {\n    head: {\n      title: 'Plataforma Inmobiliaria',\n      meta: [\n        { charset: 'utf-8' },\n        { name: 'viewport', content: 'width=device-width, initial-scale=1' },\n        { hid: 'description', name: 'description', content: 'Plataforma inmobiliaria multi-tenant' }\n      ]\n    }\n  },\n  // Asegurar que las variables de entorno estén configuradas\n  runtimeConfig: {\n    public: {\n      apiBaseUrl: process.env.API_BASE_URL || 'http://localhost:8000',\n      supabaseUrl: process.env.SUPABASE_URL,\n      supabaseKey: process.env.SUPABASE_KEY\n    }\n  }\n})\n```\n\n4. Crear un archivo `vercel.json` en la raíz del proyecto para configurar el despliegue:\n```json\n{\n  \"version\": 2,\n  \"builds\": [\n    {\n      \"src\": \"nuxt.config.js\",\n      \"use\": \"@nuxtjs/vercel-builder\",\n      \"config\": {\n        \"serverFiles\": [\"server/**\"]\n      }\n    }\n  ],\n  \"routes\": [\n    {\n      \"src\": \"/api/(.*)\",\n      \"dest\": \"/api/$1\"\n    },\n    {\n      \"src\": \"/(.*)\",\n      \"dest\": \"/\"\n    }\n  ],\n  \"env\": {\n    \"NUXT_PUBLIC_API_BASE_URL\": \"@api_base_url\",\n    \"NUXT_PUBLIC_SUPABASE_URL\": \"@supabase_url\",\n    \"NUXT_PUBLIC_SUPABASE_KEY\": \"@supabase_key\"\n  }\n}\n```\n\n5. Configurar variables de entorno en Vercel:\n   - Desde el dashboard de Vercel, añadir las variables de entorno necesarias\n   - Alternativamente, usar la CLI:\n   ```bash\n   vercel secrets add api_base_url \"https://api.plataforma-inmobiliaria.com\"\n   vercel secrets add supabase_url \"https://your-project.supabase.co\"\n   vercel secrets add supabase_key \"your-supabase-key\"\n   ```\n\n6. Desplegar a Vercel:\n   - Iniciar sesión en Vercel desde la CLI:\n   ```bash\n   vercel login\n   ```\n   - Desplegar el proyecto:\n   ```bash\n   vercel\n   ```\n   - Para despliegue a producción:\n   ```bash\n   vercel --prod\n   ```\n\n7. Configurar dominios personalizados:\n   - Desde el dashboard de Vercel, añadir dominios personalizados para cada tenant\n   - Configurar los registros DNS necesarios\n   - Verificar la propiedad del dominio\n\n8. Configurar integración continua:\n   - Conectar el repositorio de GitHub/GitLab/Bitbucket a Vercel\n   - Configurar despliegues automáticos en cada push a la rama principal\n   - Configurar previews para pull requests\n\n9. Optimizar para rendimiento:\n   - Habilitar compresión Brotli/Gzip\n   - Configurar Edge CDN\n   - Habilitar caché para recursos estáticos",
        "testStrategy": "1. Verificar el despliegue inicial:\n   - Comprobar que la aplicación se despliega correctamente en Vercel\n   - Verificar que todas las rutas funcionan como se espera\n   - Comprobar que los estilos y assets se cargan correctamente\n\n2. Probar la configuración de variables de entorno:\n   - Verificar que la aplicación puede conectarse correctamente a la API\n   - Comprobar que la autenticación con Supabase funciona en el entorno de producción\n   - Validar que las variables sensibles no se exponen en el frontend\n\n3. Validar la funcionalidad multi-tenant:\n   - Probar el acceso a través de diferentes subdominios/dominios\n   - Verificar que cada tenant ve solo sus datos correspondientes\n   - Comprobar que la resolución de tenants funciona correctamente en producción\n\n4. Realizar pruebas de rendimiento:\n   - Ejecutar Lighthouse para evaluar rendimiento, accesibilidad y SEO\n   - Verificar tiempos de carga en diferentes dispositivos y conexiones\n   - Comprobar que la aplicación cumple con los estándares de Core Web Vitals\n\n5. Probar la integración continua:\n   - Realizar un cambio menor y verificar que se despliega automáticamente\n   - Comprobar que los despliegues de preview funcionan correctamente para pull requests\n   - Verificar que los rollbacks funcionan en caso de problemas\n\n6. Validar la seguridad:\n   - Verificar que los headers de seguridad están correctamente configurados\n   - Comprobar que HTTPS está habilitado y funciona correctamente\n   - Realizar un escaneo básico de seguridad\n\n7. Probar la escalabilidad:\n   - Simular carga para verificar el comportamiento bajo tráfico elevado\n   - Comprobar que el CDN funciona correctamente para recursos estáticos\n   - Verificar que la aplicación se escala automáticamente según la demanda",
        "status": "pending",
        "dependencies": [
          29
        ],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-05T17:28:50.476Z",
      "updated": "2025-07-26T14:39:33.518Z",
      "description": "Tasks for master context"
    }
  }
}